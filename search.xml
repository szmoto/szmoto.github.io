<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[wordpress中文路径出现404错误的解决办法]]></title>
    <url>%2F2017%2F04%2F08%2Fwordpress%E4%B8%AD%E6%96%87%E8%B7%AF%E5%BE%84%E5%87%BA%E7%8E%B0404%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[http://blog.csdn.net/liu_yanzhao/article/details/54933669 方法一：修改字符编码 第一步：wp-includes/class-wp.php153 行1$pathinfo = isset( $_SERVER['PATH_INFO'] ) ? $_SERVER['PATH_INFO'] : ''; 改为1$pathinfo = isset( $_SERVER['PATH_INFO'] ) ? mb_convert_encoding($_SERVER['PATH_INFO'],'utf-8', 'GBK') : ''; 第二步：wp-includes/class-wp.php 157 行：1list( $req_uri ) = explode( '?', $_SERVER['REQUEST_URI'] ); 改为1list( $req_uri ) = explode( '?', mb_convert_encoding($_SERVER['REQUEST_URI'], 'utf-8','GBK') ); 方法二：不用中文路径，在设置–&gt;固定链接里，使用其他url方法,如图 原文地址： http://liuyanzhao.com/584.html]]></content>
      <tags>
        <tag>Wordpress</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java IO流文件的读写具体实例]]></title>
    <url>%2F2017%2F04%2F08%2Fjava-IO%E6%B5%81%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%86%99%E5%85%B7%E4%BD%93%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[http://www.cnblogs.com/chen-lhx/p/4992401.html IO流的分类： 1、根据流的数据对象来分： 高端流：所有的内存中的流都是高端流，比如：InputStreamReader 低端流：所有的外界设备中的流都是低端流，比如InputStream，OutputStream 如何区分：所有的流对象的后缀中包含Reader或者Writer的都是高端流，反之，则基本上为低端流，不过也有例外，比如PrintStream就是高端流 2、根据数据的流向来分： 输出流：是用来写数据的，是由程序（内存）&#8212;&gt;外界设备 输入流：是用来读数据的，是由外界设备&#8212;&gt;程序（内存） 如何区分：一般来说输入流带有Input，输出流带有Output 3、根据流数据的格式来分： 字节流：处理声音或者图片等二进制的数据的流，比如InputStream 字符流：处理文本数据（如txt文件）的流，比如InputStreamReader 如何区分：可用高低端流来区分，所有的低端流都是字节流，所有的高端流都是字符流 4、根据流数据的包装过程来分： 原始流：在实例化流的对象的过程中，不需要传入另外一个流作为自己构造方法的参数的流，称之为原始流。 包装流：在实例化流的对象的过程中，需要传入另外一个流作为自己构造方法发参数的流，称之为包装流。 如何区分：所以的低端流都是原始流，所以的高端流都是包装流 IO流对象的继承关系(如下图)： 下面来看一些具体的代码例子： 按字节来读取文件123456789101112131415161718192021222324252627282930313233343536373839404142public class ReadFromFile &#123; /** * 以字节为单位读取文件，常用于读二进制文件，如图片、声音、影像等文件。 */ public static void readFileByBytes(String fileName) &#123; File file = new File(fileName); InputStream in = null; try &#123; System.out.println(&amp;quot;以字节为单位读取文件内容，一次读一个字节：&amp;quot;); // 一次读一个字节 in = new FileInputStream(file); int tempbyte; while ((tempbyte = in.read()) != -1) &#123; System.out.print(tempbyte); &#125; in.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); return; &#125; try &#123; System.out.println(&amp;quot;以字节为单位读取文件内容，一次读多个字节：&amp;quot;); // 一次读多个字节 byte[] tempbytes = new byte[100]; int byteread = 0; in = new FileInputStream(fileName); ReadFromFile.showAvailableBytes(in); // 读入多个字节到字节数组中，byteread为一次读入的字节数 while ((byteread = in.read(tempbytes)) != -1) &#123; System.out.print(tempbytes, 0, byteread); &#125; &#125; catch (Exception e1) &#123; e1.printStackTrace(); &#125; finally &#123; if (in != null) &#123; try &#123; in.close(); &#125; catch (IOException e1) &#123; &#125; &#125; &#125; &#125; 按字符来读取文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * 以字符为单位读取文件，常用于读文本，数字等类型的文件 */ public static void readFileByChars(String fileName) &#123; File file = new File(fileName); Reader reader = null; try &#123; System.out.println(&amp;quot;以字符为单位读取文件内容，一次读一个字符：&amp;quot;); // 一次读一个字符 reader = new InputStreamReader(new FileInputStream(file)); int tempchar; while ((tempchar = reader.read()) != -1) &#123; // 对于windows下，\r\n这两个字符在一起时，表示一个换行。 // 但如果这两个字符分开显示时，会换两次行。 // 因此，屏蔽掉\r，或者屏蔽\n。否则，将会多出很多空行。 if (((char) tempchar) != '\r') &#123; System.out.print((char) tempchar); &#125; &#125; reader.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; try &#123; System.out.println(&amp;quot;以字符为单位读取文件内容，一次读多个字符：&amp;quot;); // 一次读多个字符 char[] tempchars = new char[30]; int charread = 0; //由于要以字符来读取，所以需要套上字符流 reader = new InputStreamReader(new FileInputStream(fileName)); // 读入多个字符到字符数组中，charread为一次读取字符数 while ((charread = reader.read(tempchars)) != -1) &#123; // 同样屏蔽掉\r不显示 if ((charread == tempchars.length) &amp;amp;amp;&amp;amp;amp; (tempchars[tempchars.length - 1] != '\r')) &#123; System.out.print(tempchars); &#125; else &#123; for (int i = 0; i &amp;amp;lt; charread; i++) &#123; if (tempchars[i] == '\r') &#123; continue; &#125; else &#123; System.out.print(tempchars[i]); &#125; &#125; &#125; &#125; &#125; catch (Exception e1) &#123; e1.printStackTrace(); &#125; finally &#123; if (reader != null) &#123; try &#123; reader.close(); &#125; catch (IOException e1) &#123; &#125; &#125; &#125; &#125; 按行来读取文件1234567891011121314151617181920212223242526272829/** * 以行为单位读取文件，常用于读面向行的格式化文件 */ public static void readFileByLines(String fileName) &#123; File file = new File(fileName); BufferedReader reader = null; try &#123; System.out.println(&amp;quot;以行为单位读取文件内容，一次读一整行：&amp;quot;); reader = new BufferedReader(new FileReader(file)); String tempString = null; int line = 1; // 一次读入一行，直到读入null为文件结束 while ((tempString = reader.readLine()) != null) &#123; // 显示行号 System.out.println(&amp;quot;line &amp;quot; + line + &amp;quot;: &amp;quot; + tempString); line++; &#125; reader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (reader != null) &#123; try &#123; reader.close(); &#125; catch (IOException e1) &#123; &#125; &#125; &#125; &#125; 将一个文件的内容写入另一个文件(按行来写)123456789101112131415161718192021222324252627public class FileTest &#123;public static void main(String[] args) &#123; File file=new File(&amp;quot;c:\\test.txt&amp;quot;); BufferedReader read=null; BufferedWriter writer=null; try &#123; writer=new BufferedWriter(new FileWriter(&amp;quot;c:\\zwm.txt&amp;quot;)); &#125; catch (IOException e1) &#123; e1.printStackTrace(); &#125; try &#123; read=new BufferedReader(new FileReader(file)); String tempString = null; while((tempString=read.readLine())!=null)&#123; writer.append(tempString); writer.newLine();//换行 writer.flush();//需要及时清掉流的缓冲区，万一文件过大就有可能无法写入了 &#125; read.close(); writer.close(); System.out.println(&amp;quot;文件写入完成...&amp;quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125;&#125; &nbsp;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntelliJ IDEA 2016.1建立Strut2工程并使用Tomcat调试]]></title>
    <url>%2F2017%2F03%2F25%2FIntelliJ-IDEA-2016-1%E5%BB%BA%E7%AB%8BStrut2%E5%B7%A5%E7%A8%8B%E5%B9%B6%E4%BD%BF%E7%94%A8Tomcat%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[http://www.mobibrw.com/2016/3494 IntelliJ IDEA 2016.1建立 Strut2工程的步骤如下： 1.从菜单中选择新建工程： 2.在弹出的窗口中，左侧的列表中，选择&#8221; Java&#8220;,在右侧的&#8221; Project SDK&#8220;中指明需要的 Java SDK的版本，目前要求是1.8版本的，在下面的&#8221; AdditionalLibraries and Frameworks&#8220;中找到&#8221; Struts 2&#8220;,并选中,同时选中&#8221; WebApplication&#8220;。 3.点击下面的&#8221; Next&#8220;按钮。 4.等待 IntelliJ IDEA下载完成必须的插件。点击左侧的&#8221; Project&#8220;边栏，之后可以到如下界面. 点击右侧的&#8221; Project Stucture&#8220;按钮，如下图： 修复存在的问题： 点击后出现的界面如下： 在弹出的菜单中，选择&#8221; Put into /Web&#8211;INF/lib&#8220;。 配置完成后的界面如下： 点击&#8221; OK&#8220;，关闭窗口。 5.编辑配置信息&#8221; Edit Configurations&#8220; 6.在弹出的界面中点开右侧的&#8221;+&#8221;符号,也可以点击左侧顶部的&#8221;+&#8221;号。 7.在弹出的界面中，一直下拉，找到&#8221; Tomcat Server&#8220;,点击展开，选择&#8221;Local&#8220; 8.下载并安装Tomcat 9 Windows下面，建议安装 &#8221; 32&#8211;bit/64&#8211;bit Windows Service Installer&#8221; 9.安装最新的 Java SE Development Kit 目前最新的版本是 8u73。保证电脑上面是最新的，如果使用 JDK 7的话，会由于 Tomcat的版本号太高导致在调试的时候报告如下错误： 12Application Server was not connected before run configuration stop, reason: Unable to ping server at localhost:9099 这个错误的原因是由于 JDK 1.7是默认没有包含 JMS服务的，导致 Idea通过JMS跟 Tomcat通信的时候失败。 10.设置 Tomcat Server 配置完成后的界面显示如下： 此时底部提示&#8221; Warning No artificts configured&#8220;,点击底部的&#8221; Fix&#8220;按钮。 出现的窗口中自动帮我们加入了&#8221; Tools:war exploded&#8220;项目，点击下面的&#8221;Apply&#8220;按钮后，点击&#8221; OK&#8220;关闭设置页面。 11.调试，点击主界面上面的调试图标，即可进入调试，此时会在默认的浏览器上打开网页。 最后，浏览器上出现如下画面，说明设置成功。 12.创建一个简单的 Stucts2的 MVC例子&#8212;- TimeConvert (1)先创建一个 Model类来存放数据 首先，在 src目录上鼠标右击，选择&#8221; New&#8220;-&gt; &#8221; Java Class&#8220;并在对话框中输入名字&#8221; Tools.Model.TimeConvertStore&#8220;，点击&#8221; OK&#8220;。 里面的代码如下： 1234567891011121314package Tools.Model;public class TimeConvertStore { public String getConvertTime() { return convertTime; } public void setConvertTime(String time) { this.convertTime = time; } private String convertTime;} 这个 Model类的 public set和 get方法允许访问 private convertTime字符串属性，Struts 2框架需要将这个对象按照 JavaBean方式暴露给 View(TimeConvert.jsp)。 (2)创建 View页面来显示 Model类里存储的 convertTime. 在 web目录上鼠标右击，选择&#8221; New&#8220;-&gt; &#8221; File&#8220;并在对话框中输入名字&#8221;TimeConvert.jsp&#8220;，点击&#8221; OK&#8220;新建一个 TimeConvert.jsp的 jsp页面. 代码如下： 12345678910&lt;%@ page contentType=&#8220;text/html;charset=UTF-8&#8221; language=&#8220;java&#8221; %&gt;&lt;%@ taglib prefix=&#8220;s&#8221; uri=&#8220;/struts-tags&#8221; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;&lt;s:property value=&#8220;timeConvertStore.convertTime&#8221; /&gt;&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; 页面中的 taglib告诉 Servlet容器这个页面将使用 Struts 2的 tags并且将它们用 s来表示。 s:property的 tag标签返回调用 TimeConvertAction controller class的getTimeConvertStore方法后的值。这个方法返回一个 TimeConvertStore对象。在TimeConvertStore加上了 .convertTime后，就可以告诉 Struts 2框架将调用TimeConvertStore的 getConvertTime方法。 TimeConvertStore的 getConvertTime方法返回一个字符串，然后这个字符串将被 s:property标签显示。 (3)创建一个 Action类 TimeConvertAction.java作为 Controller. 在 src目录上鼠标右击，选择&#8221; New&#8220;-&gt;&#8221; Java Class&#8220;并在对话框中输入名字&#8221;Tools.Controller.TimeConvertAction&#8220;，点击&#8221; OK&#8220;. 代码如下： 1234567891011121314151617181920212223242526272829package Tools.Controller;import Tools.Model.TimeConvertStore;import com.opensymphony.xwork2.ActionSupport;import java.text.SimpleDateFormat;import java.util.Date;public class TimeConvertAction extends ActionSupport { public String execute() throws Exception { timeConvertStore = new TimeConvertStore(); SimpleDateFormat df = new SimpleDateFormat(&#8220;yyyy-MM-dd HH:mm:ss&#8221;);//设置日期格式 timeConvertStore.setConvertTime(df.format(new Date())); return SUCCESS; } public TimeConvertStore getTimeConvertStore() { return timeConvertStore; } public void setTimeConvertStore(TimeConvertStore timeConvertStore) { this.timeConvertStore = timeConvertStore; } private TimeConvertStore timeConvertStore; private static final long serialVersionUID = 1L;} (4)增加 struts配置到 struts.xml文件中 建立映射关系，将 TimeConvertAction类（ Controller）和 TimeConvert.jsp（View）映射在一起。映射后， Struts 2框架就能够知道哪个类将响应用户的 action（the URL），这个类的哪个方法将被调用，哪个 View能够得到这个方法的返回String结果。 12345678910111213&lt;?xml version=&#8220;1.0&#8221; encoding=&#8220;UTF-8&#8221;?&gt;&lt;!DOCTYPE struts PUBLIC &#8220;-//Apache Software Foundation//DTD Struts Configuration 2.3//EN&#8221; &#8220;http://struts.apache.org/dtds/struts-2.3.dtd&#8221;&amp;gt;&lt;struts&gt; &lt;package name=&#8220;Tools&#8221; extends=&#8220;struts-default&#8221;&gt; &lt;action name=&#8220;TimeConvert&#8221; class=&#8220;Tools.Controller.TimeConvertAction&#8221; method=&#8220;execute&#8221;&gt; &lt;result name=&#8220;success&#8221;&gt;/TimeConvert.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; (5)在 index.jsp中增加链接 首先在 jsp页面顶部增加 taglib说明 1&lt;%@ taglib prefix=&#8220;s&#8221; uri=&#8220;/struts-tags&#8221; %&gt; 然后在 body标签后增加 p标签 1&lt;p&gt;&lt;a href=&#8220;&lt;s:url action=&#8217;TimeConvert&#8217;/&gt;&#8221;&gt;TimeConvert&lt;/a&gt;&lt;/p&gt; 修改后的代码如下： 12345678910&lt;%@ page contentType=&#8220;text/html;charset=UTF-8&#8221; language=&#8220;java&#8221; %&gt;&lt;%@ taglib prefix=&#8220;s&#8221; uri=&#8220;/struts-tags&#8221; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;&lt;a href=&#8220;&lt;s:url action=&#8217;TimeConvert&#8217;/&gt;&#8221;&gt;TimeConvert&lt;/a&gt;&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 点击调试后，运行效果如下图： 点击超链接后显示如下： 13.增加多语言支持 i18n 需要注意的是，对于 index.jsp中读取全局配置文件，需要先增加 Spring框架，否则是无法通过在 struts.xml中增加 1&lt;constant name=&#8220;struts.custom.i18n.resources&#8221; value=&#8220;global&#8221; /&gt; 来实现的。如下图所示： 在跟&#8221; TimeConvertAction.java&#8220;相同的目录下面建立英文语言文件TimeConvertAction_en.properties，中文语言文件 TimeConvertAction_zh.properties,注意，中文只能是Unicode编码的格式，否则会出现乱码。格式类似\u65f6\u95f4\u8f6c\u6362这样的格式。 其中 TimeConvertAction_en.properties中的内容如下： 1Title=TimeConvert TimeConvertAction_cn.properties中的内容如下： 1Title=\u65f6\u95f4\u8f6c\u6362 然后修改 TimeConvert.jsp,在Title中引用我们定义的语言。修改 1&lt;title&gt;Title&lt;/title&gt; 为： 1&lt;title&gt;&lt;s:text name=&#8220;Title&#8221;/&gt;&lt;/title&gt; 修改后的 TimeConvert.jsp文件如下： 12345678910&lt;%@ page contentType=&#8220;text/html;charset=UTF-8&#8221; language=&#8220;java&#8221; %&gt;&lt;%@ taglib prefix=&#8220;s&#8221; uri=&#8220;/struts-tags&#8221; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;s:text name=&#8220;Title&#8221;/&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;&lt;s:property value=&#8220;TimeConvertStore.convertTime&#8221; /&gt;&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; 点击调试后，打开的页面中，会看到网页的Title变成了中文的&#8221;时间转换&#8221;。 14. Strut2增加对 Json的支持 默认情况下 Struts2不支持直接返回 JSON，比较方便的方式是使用 struts2&#8211;json&#8211;plugin来支持。 (1)增加 spring框架，由于 struts2&#8211;json&#8211;plugin需要调用spring框架，因此需要增加spring框架。右击工程，选择&#8221; Add Framework Support...&#8220;。 在弹出的窗口中，选择&#8221; Spring&#8220;,&#8221; Spring MVC&#8220;两项，同时在点击&#8221; Spring&#8220;的时候，勾选&#8221; Create emtpy spring&#8211;config.xml&#8220;。 然后点击&#8221; OK&#8220;，等待需要的 Jar包下载完成。成功下载完成后，可以在 lib目录下看到非常多的 Jar文件被添加进来了。在 web目录下的 WEB&#8211;INF目录下多出来了 applicationContext.xml, dispatcher&#8211;servlet.xml这两个文件。 完成后点击界面上侧的&#8221; Project Structure&#8220;图标，解决提示的 Jar包导出问题。 都选择第一项&#8221; Add &#8216;xxxxxxxxxxx&#8217; to the artifact&#8220;. （2）确认项目使用的 Struts2的版本。点击界面上侧的&#8221; Project Structure&#8220;图标 从上图可以看到我们的 Struts2的版本是 2.3.20.1 （3）手工去下载struts2-json-plugin插件，选择与我们的 Struts2的版本相同的版本的插件。之所以需要手工下载而不是要求 IntelliJ IDEA在 Maven中自动下载原因在于，由于我们建立项目的时候没有使用 Maven，因此我们项目 Lib目录下的 Struts2的 Jar包是没有带版本号的。而如果要求 Maven自动下载的话，会由于找不到带版本号的 Struts2的 Jar包，而自动引入一堆的带版本号的Struts2的 Jar包。导致 Struts2的 Jar包出现两份，一份是有版本号的，一份是我们现在的样子。导致无法编译通过，因此还是手工引入即可。 由于我们的 Struts2的版本是 2.3.20.1，因此，我们下载 2.3.20.1版本的struts2&#8211;json&#8211;plugin. 下载完成后放到项目的 lib目录下，然后右击 struts2&#8211;json&#8211;plugin&#8211;2.3.20.1.jar,选择&#8221; Add As Library&#8220;. 点击 OK后关闭。 继续点击界面右上侧的&#8221; Project Structure&#8220;图标 修改 src目录下的 struts.xml。调整部分如下图所示。 action的返回类型为 json时的可配置参数详解： 1234567891011&lt;result type=&#8220;json&#8221;&gt; &lt;!&#8211; 这里指定将被Struts2序列化的属性，该属性在action中必须有对应的getter方法 &#8211;&gt; &lt;!&#8211; 默认将会序列所有有返回值的getter方法的值，而无论该方法是否有对应属性 &#8211;&gt; &lt;param name=&#8220;root&#8221;&gt;dataMap&lt;/param&gt; &lt;!&#8211; 指定是否序列化空的属性 &#8211;&gt; &lt;param name=&#8220;excludeNullProperties&#8221;&gt;true&lt;/param&gt; &lt;!&#8211; 这里指定将序列化dataMap中的那些属性 &#8211;&gt; &lt;param name=&#8220;includeProperties&#8221;&gt;userList.*&lt;/param&gt; &lt;!&#8211; 这里指定将要从dataMap中排除那些属性，这些排除的属性将不被序列化，一般不与上边的参数配置同时出现 &#8211;&gt; &lt;param name=&#8220;excludeProperties&#8221;&gt;SUCCESS&lt;/param&gt; &lt;/result&gt; 15.参考链接： 经验分享：IntelliJ IDEA 10.x中配置支持Struts 2的HelloWorld样例 Localization, internationalization (i18n) Struts2返回JSON对象的方法总结 Struts 2 – i18n or localization example]]></content>
      <tags>
        <tag>Java</tag>
        <tag>JavaEE</tag>
        <tag>JSP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Visual Studio 2017 各版本安装包离线下载、安装全解析]]></title>
    <url>%2F2017%2F03%2F10%2FVisual-Studio-2017-%E5%90%84%E7%89%88%E6%9C%AC%E5%AE%89%E8%A3%85%E5%8C%85%E7%A6%BB%E7%BA%BF%E4%B8%8B%E8%BD%BD%E3%80%81%E5%AE%89%E8%A3%85%E5%85%A8%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[http://www.oschina.net/news/82731/vs-2017-all-version-offline-download-and-install 关于 Visual Studio 2017 各版本安装包离线下载、更新和安装的方法以及通过已下载版本减少下载量的办法。 微软最近发布了正式版 Visual Studio 2017 并公开了其下载方式，不过由于 VS2017 采用了新的模块化安装方案，所以微软官方并未提供 ISO 镜像，但是官方提供了如何进行离线下载的方案给需要进行离线安装的用户，只不过都是英文。本文将对官方指南中的一部分进行翻译（这里说一句：翻译的部分就是最基础的离线下载和安装方案，另外，即使如以前微软提供了安装镜像，也仅会包含 Visual Studio 的基本核心组件和部分官方扩展，而微软、安卓和苹果等平台的 SDK、模拟器和第三方扩展功能等会在用户选择后联网下载。而 VS2017 的离线包是包含所有可选项的）。好了，接下来将会分为四部分来叙述，分别是离线下载安装文件、离线安装 VS2017、更新离线文件包以及如何通过已下载版本来减少下载其它版本下载量的方法。 第一部分：离线下载安装文件这里描述是包括所有版本，截图以下载 VS2017 社区版为例： ①登入 VS 官网下载页面，选择需要的版本点击下载，下载页点此进入。 ②下载完成后，打开下载文件所在文件夹，Windows 8.1 及以上版本用户点击资源管理器上的文件-打开命令提示符-以管理员身份打开命令提示符；Windows7 用户可在该文件夹空白处按住 Shift 键的情况下点击鼠标右键选择“在此处打开命令窗口”。 ③根据自己下载的 VS2017 版本，在打开的命令提示符窗口输入下面对应的命令并点击回车，等待程序启动即会开始下载（以下命令用于下载完整版离线包，包含全功能以及全语言包，其中红色部分为下载文件存放路径，根据自身情况用户可自行更改） 企业版： vs_enterprise.exe &#8211;layout c:\vs2017offline 专业版： vs_professional.exe &#8211;layout c:\vs2017offline 社区版： vs_community.exe &#8211;layout c:\vs2017offline 如果需要下载单一语言的或其中某几种语言的离线文件，可采用以下命令： 企业版：vs_enterprise.exe &#8211;layout c:\vs2017offline &#8211;lang zh-CN 专业版：vs_professional.exe &#8211;layout c:\vs2017offline &#8211;lang zh-CN 社区版：vs_community.exe &#8211;layout c:\vs2017offline &#8211;lang zh-CN 红色代码为语言参数，这里提供三种语言的参数供大家选择 英语（美国）：en-US 中文：zh-CN（简体），zh-TW（繁体） 日语：ja-JP 如果需要同时下载多种语言，可以在 &#8211;lang 后面连续加上多个语言代码参数，用空格间隔开就行，比如 — lang en-US zh-CN ja-JP，那么就会同时下载英文、中文和日文语言包。 ④如需更多语言包或者更多安装指令，请参考官方离线安装命令指南：点此进入。 ⑤等待文件下载，不要关闭文件下载窗口，等所有文件下载完成后该窗口会自动关闭，下载过程中不要断电断网，也不要关闭窗口，当然，如果断电断网或者关闭了下载窗口，没关系，输入命令重头来过，还是会继续下载的。 第二部分：离线安装本部分以安装社区版为例，其他版本安装过程一样，只是专业版和企业版需要激活授权。 ①打开刚刚存放离线文件的路径，比如 E:\vs2017offline，然后找到 certificates 文件夹并打开，依次安装该文件夹下的软件证书。双击证书并根据提示往下走就行了，实在懒得弄就一直下一步直到提示导入成功。 ②运行离线根目录下的安装程序，各版本位置如下： 企业版：离线文件存储文件夹\vs_Enterprise.exe 专业版：离线文件存储文件夹\vs_Professional.exe 社区版：离线文件存储文件夹\vs_Community.exe ③安装程序运行后，选择自己需要的模块和功能，确认所需后点击安装即可。顺便吐槽一下，社区版全工作负荷、全组件以及全语言包选择后需要空间 93.85GB，所以大家还是选择自己需要的安装就行了……另外，需要 Python 扩展支持的朋友，可以自己下载 Python 安装，或者安装完成后自行到扩展添加，官方安装文件对 Python 扩展的包含据说要等下次更新…… ④等待安装完成即可使用了。 第三部分：更新离线文件包这部分比较简单，步骤如下： ①当微软提示有版本更新后，到官网下载最新的在线安装执行文件，下载地址：点此进入。 ②按步骤执行本文第一部分下载离线安装文件的步骤，但是必须注意，&#8211;layout 后的下载文件夹路径必须是旧版本离线文件存储的位置（如果你之前下载好没移动过那就是之前的下载路径），执行命令后安装程序会扫描已有文件并下载更新文件和新增文件。 ③更新完成后可再次执行离线文件夹根目录下的安装程序进行软件更新，或者 VS 中直接检查更新，更新新版本理论上无需重新导入证书除非有新证书被下载。 第四部分：通过已下载版本减少其他版本离线下载量这部分也很简单，原理就是社区版、专业版和企业版有大多数组件其实是相同，如果用户想离线下载所有版本，那么没有那个必要，企业版包含了其它所有版本的组件，所以理论上用户只用下载企业版即可，安装时是可选择安装社区版、专业版或者企业版的。当然目前前面所述只是理论，毕竟我没试验，当然以下方法可以百分百保证需要的用户用最少的下载量完成下载所有版本的 VS2017。 如果你已经下载好了其中一版，均可进行如下操作： ①创建两个新文件夹，根据你自己的爱好重命名，最好是英文名。 ②将已经下好的版本的所有文件都分别复制到这两个新文件夹中，并删除由之前下载程序下载在根目录下的六个文件。 ③下载另外两个版本的安装程序，接下来就是重复第一部分的步骤，但是命令行命令—layout后的路径参数根据版本分别设置为你刚刚新建的那两个文件夹。 ④回车执行命令，程序会扫描和检查已经下载的组件，并现在自己版本对应的缺少的以及匹配的组件，不过这部分大小不会超过 1GB，准确来说可能只有几十兆左右…… ⑤等待完成，反正不一会儿就好了，然后就可以收藏三个版本的离线包了。 ⑥至于更新嘛，参见第三部分。 第五部分：附加这部分呢是附加的一部分，信息是完全下载（包含全功能全语言包）的社区版和企业版的详细文件信息，以及他们的差集文件夹信息；最大的是企业版，最小的是企业版和社区版文件夹差集的信息。最后就是，各版本离线包里面至少含以下关键字的文件夹中的内容是完全一模一样的，就是：SDK、.NET、Xamarin、Unity、Cocos、Unreal、Linux、Mac、iOS、Android、emulator……包含这些关键词的文件夹，大小合计应该超过 16GB 了…… 最后嘛就是，学习编程是条非常非常痛苦和漫长的路哪，它没我们想象的那么简单，因为实际上你要学的东西并不仅仅只是编写代码……当然学习也是快乐的，每当攻破一个难题带来的成就感总会驱使你继续向更高的成就努力~~哈哈，其实我就是想说，有没有想一起自学 C# 和 .NET 的童鞋哪？]]></content>
      <tags>
        <tag>VisualStudio</tag>
        <tag>visualstudio</tag>
        <tag>VS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android NDK编译选项设置]]></title>
    <url>%2F2017%2F03%2F04%2FAndroid-NDK%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[http://crash.163.com/#news/!newsId=24 在Android NDK开发中，有两个重要的文件：Android.mk和Application.mk，各尽其责，指导编译器如何编译程序，并决定编译结果是什么。本文将详细说明几个常见的NDK选项的配置，帮助大家理解相应的配置选项。 #### 一、Application.mk Application.mk实际上是轻量级Makefile，通常在$PROJECT/jni目录下，用于配置所有modules的编译变量，例子如下： APP_ABI := armeabi arm64-v8a x86_64 x86 armeabi-v7a NDK_TOOLCHAIN_VERSION := clang3.5 APP_STL := stlport_static APP_OPTIM：= debuge 1**、APP_ABI（目标平台ABI类型）** NDK编译中，APP_ABI默认选择armeabi ABI，可通过设置APP_ABI设置一个或者多个ABI，表一为不同的APP_ABI所对应的指令集。 Instrunction setValueARMv5TE based CPUAPP_ABI := armeabiARMv7 based CPUAPP_ABI := armeabi-v7aARMv8 AArch64APP_ABI := arm64-v8aIA-32APP_ABI := x86Intel64APP_ABI := x86_64MIPS32APP_ABI := mipsMIPS64(r6)APP_ABI := mips64All supported instruction setsAPP_ABI := all 表一：ABI类型 在开发时可根据需求选择APP_ABI，对于ABI的选择需要考虑到效率和APK大小。由于armeabi-v7a指令集兼容armeabi；市面上的x86手机为了兼容性，基本都使用libhoudini模块，兼容arm指令集；64位机型默认支持32位abi的so，因此在对大小要求比较高的情况下，可以只选择市面上设备基本兼容的armeabi ABI，如果对性能有些许要求，可以再添加x86 ABI。 2**、 NDK_TOOLCHAIN_VERSION（编译器类型、版本）** 默认采用的是GCC编译器，对于GCC版本的选择与NDK版本有关系，本人使用的是NDK R12，在64位ABI默认是GCC 4.9，32位ABI默认是GCC 4.8，当然也可以像上面例子中给出的设置一样，设置clang编译器。 3**、 APP_STL（运行库类型）** Android NDK 默认使用的是最小支持的C++运行库，如果你需要你的NDK程序中使用STL，则可以设置APP_STL := stlport_static，APP_STL有表二中的几种取值。 NameExplanationsystem(default)系统默认的C++运行库stlport_static以静态链接方式使用的sttport版本的STLstlport_shared以动态链接方式使用的sttport版本的STLgnustl_static以静态链接方式使用的gnustl版本的STLgnustl_shared以动态链接方式使用的gnustl版本的STLgabi++_static以静态链接方式使用的gabi++gabi++_shared以动态链接方式使用的gabi++c++_static以静态链接方式使用的LLVM libc++c++_shared以动态链接方式使用的LLVM libc++ 表二：NDK运行库 若APK中有多个SO文件用到STL，建议都使用动态方式链接STL，这样可以减小整个APK文件大小。 另外需要注意的是官方提供的NDK运行库除了默认的以外都支持RTTI和异常，然而默认是禁用的，将在下面的Android.mk中说明如何开启。 4**、APP_OPTIM（编译模式）** “release”模式为默认的，生成的是优化后的二进制；也可以设置为“debug”模式，“debug”模式生成的是未优化二进制，提供很多BUG信息，便于调试和分析。 还有其他配置选项，有兴趣可以查看Application.mk官方文档。 二、Android.mkAndroid.mk也是一个轻量级的Makefile，其将C/C++源码组织到一个个module中，module可以是静态库、共享库或者独立的可执行文件， 一个Android.mk文件可以有一个，也可以是多个module，modules之间也可以有依赖关系。 1、基本概念 Android.mk中包括NDK提供的宏、变量以及模块描述变量，这些宏、变量以及变量的赋值共同组成了Android.mk文件，其在NDK编译中各尽其责，指导着NDK的编译。 宏：包括my-dir、all-subdir-makefiles等，通过‘$(call &lt;function&gt;)’来调用，返回文本信息。 变量：包括CLEAR_VARS、BUILD_SHARED_LIBRARY、TARGET_ARCH等，由NDK编译系统提供，并且在Android.mk文件被解析前就已经存在。Android.mk文件有可能被多次解析，因此每次解析时这些变量的值都有可能不同。 模块描述变量：Module-description，包括LOCAL_PATH、LOCAL_MODULE、LOCAL_SRCFILES等LOCAL前缀变量，这些变量除LOCAL_PATH外，均填写在语句include $(CLEAR_VARS)和include $(BUILD_XXX)之间。 其他Android.mk配置可以查看Android.mk官方文档。 2、基础 在Android.mk中包括一些很基础的变量，下面的栗子包括了基础的变量，本人将详细说明。 LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) LOCAL_MODULE := hello-jni LOCAL_SRC_FILES := hello-jni.c include $(BUILD_SHARED_LIBRARY) LOCAL_PATH**（当前目录） ** LOCAL_PATH为模块描述变量，一个Android.mk必须定义LOCAL_PATH，用于定位源文件，在本例中，使用的是编译系统提供的宏“my-dir”（“my-dir”返回最近一次包括Makefile文件路径，通常为当前Android.mk所在目录），用于返回当前目录。 此变量不会被CLEAR_VARS清除，所以每个Android.mk文件只需要定义一次就可以了。 CLEAR_VARS**（变量清除）** CLEAR_VARS变量由编译系统提供，顾名思义，作用是清除模块变量（在include $(CLEAR_VARS)和include $(BUILD_XXX)之间的LOCAL_XXX模块变量），当然LOCAL_PATH除外。由于所有的编译控制文件都是单一的GNU Make可执行上下文环境中解析，而这个上下文环境中所有的变量都是全局的，所以编译module前需要清理相应变量。 LOCAL_MODULE**（module名称）** LOCAL_MODULE是Android.mk文件中module的唯一标识，这个名字必须是唯一的，且中间不能有空格。在默认情况下，它决定了生成的文件名，如“hello-jni”对应的动态库名称为libhello-jni.so，然而要索引它时，需要“hello-jni”即可，也可以通过变量LOCAL_MODULE_FILENAME来覆盖这个默认名称。 LOCAL_SRC_FILES **（源码文件）** LOCAL_SRC_FILES 变量包括C/C++源文件列表，这些源文件会被编译到一个module中，不过也不必列出头文件和包括文件，编译系统会自动为你找打所有需要的依赖关系。值得注意的是linux下路径使用顺斜杠（/）。 BUILD_SHARED_LIBRARY**（动态库编译）** BUILD_SHARED_LIBRARY是编译器提供的变量，表示编译成动态库，它指向一个GNU Makefile脚本，这个脚本收集从include $(CLEAR_VARS)后所有的LOCAL_XXX变量中定义的所有信息，决定编译什么以及怎么编译。 还有BUILD_STATIC_LIBRARY，和BUILD_SHARED_LIBRARY类似，表示编译成静态库，静态库不会被拷贝到APK中。 PREBUILT_SHARED_LIBRARY**（预编译）** 指向一个编译脚本，用来指定一个预编译动态库.使用此变量时，不像BUILD_SHARED_LIBRARY和BUILD_STATIC_LIBRARY那样，LOCAL_SRC_FILES的值必须是只能有一个指向预编译动态库的路径，如foo/libfoo.so，而不是源文件。如下栗子。 include $(CLEAR_VARS) LOCAL_MODULE := test LOCAL_SRC_FILES := lib/$(TARGET_ARCH_ABI)/libtest.so include $(PREBUILT_SHARED_LIBRARY) PREBUILD_STATIC_LIBRARY和PREBUILD_SHARED_LIBRARY一样，只不过是用于引用静态库。 TARGET_ARCH_ABI**（目标ABI名称）** 如表一所示，目标ABI名称。若定义了多个ABI，则每次解析Android.mk时,值都不一样，主要使用场景为根本不同的ABI定义不同的文件等。 3、其他模块变量LOCAL_LDLIBS（链接库） 用于额外链接选项，所有的库都有“-l”前缀。可同时列出多个库，用空格隔开，例如： LOCAL_LDLIBS := -llog -ldl Android NDK默认链接了多个库，不需要显示的添加到LOCAL_LDLIBS中，包括 the standard C libraries，the standard C++ libraries，real-time extensions和 pthread库。同时也提供了一些需要显示添加的库，这些库版本有关系，如表三所示。 Android levelLibExplanationAndroid-3-llogAndroid Log-lzZlib Compression Library-ldlDynamic Linker LibraryAndroid-4-lGLESv1_CMOpenGL ES 1.x LibraryAndroid-5-lGLESv2OpenGL ES 2.0 LibraryAndroid-8-ljnigraphicsThe jnigraphics LibraryAndroid-9-lEGLThe EGL graphics library-lOpenSLESOpen ES native audio Library-landroidNatice Android APIAndroid-14-lOpenMAXALOpenMAX AL natice multimedia LibraryAndroid-18-lGLESv3OpenGL ES 3.0 LibraryAndroid-21-lGLESv3OpenGL ES 3.1 Library 表三：链接库 LOCAL_CFLAGS**、LOCAL_CPPFLAGS和LOCAL_LDFLAGS（编译、链接标志）** LOCAL_CFLAGS定义的是在编译C/C++时，传递给编译器的标志集合，LOCAL_CPPFLAGS只支持C++，作用也是传递给编译器一些信息，LOCAL_LDFLAGS是指传递给连接器一些额外的参数。 在NDK开发中难免会用到这些标志位，特别是在优化编译时，下面的是本人在开发中遇到的编译选项。 ① LOCAL_CPPFLAGS += -fexceptions 由于NDK编译从R5开始才支持C++异常控制，为了通用性，异常处理默认是禁用的（-fno-exceptions），因此需要在指定module中添加LOCAL_CPPFLAGS += -fexceptions编译选项方可编译带异常处理的C++代码。也可以直接在Application.mk中配置APP_CPPFLAGS += -fexceptions。 ② LOCAL_CPPFLAGS += -frtti 从NDK R5开始，NDK也开始支持C++ RTTI了，但为了通用性，所有的C++源文件被构建的时候默认是不支持RTTI的（-fno-rtti），可以通过在Android.mk中添加：LOCAL_CPPFLAGS += -frtti或者在Application.mk添加APP_CPPFLAGS += -frtti来开启RTTI。 ③ LOCAL_CFLAGS += -fvisibility=hidden 在NDK开发中，源文件的函数都有一个默认的visibility属性为public，编译生成的so文件中几乎所有的函数名、全局变量名均被导出，其实只需要导出java_com开头的jni函数即可，其他函数不需要暴露出来，在Android.mk中设置LOCAL_CFLAGS += -fvisibility=hidden，就可以隐藏不需要导出的函数，若某个函数需要导出，则添加JNIEXPORT或者attribute ((visibility (&#8220;default&#8221;)))即可。 除了安全，不导出不必要的函数外，还能减小so体积。 ④ LOCAL_CFLAGS += -ffunction-sections 不添加此参数时，编译文件.o中代码部分只有.text段，使用此参数，会使每个函数单独有一个段，举个栗子，函数func1()会编译成.text.func1段，虽然段多了，但对链接后代码大小并没有影响。 ⑤ LOCAL_CFLAGS += -fdata-sections 同上，每个data都有一个单独的段。 ⑥ LOCAL_LDFLAGS += -Wl &#8211;gc-sections -Wl,&lt;option&gt;选项是告诉编译器，将后面选项&lt;option&gt;传递给连接器，-Wl,&#8211;gc-sections的意思是使用连接器ld链接时删除不用的段。若使用LOCAL_CFLAGS += -ffunction-sections -fdata-sections，则代码和数据均被分割成不同的段，若某个函数或数据未被任何函数调用，则ld不会链接未被调用的函数，从而减小so文件体积，达到优化so的目的。 ⑦ LOCAL_LDFLAGS += -fPIC PIC(position independent code)用于编译位置无关代码，生成可用于共享库的位置独立代码。若不添加-fPIC，则加载.so文件的代码段时，代码段引用的数据对象需要重定位，重定位会修改代码段内容，这样就导致没使用这个.so，代码段的进程在内核中就会生成这个文件的拷贝。 ⑧ LOCAL_LDFLAGS += -Wall 这个的意思是wring all 意思在编译和链接过程中显示所有警告信息。 ⑨其他 若需要了解其他编译标志，可以查看GCC Command Options 文档。]]></content>
      <tags>
        <tag>Android</tag>
        <tag>ndk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将Cocos2d-x的libcurl单独打包到Android]]></title>
    <url>%2F2017%2F03%2F04%2Fe5-b0-86cocos2d-x-e7-9a-84libcurl-e5-8d-95-e7-8b-ac-e6-89-93-e5-8c-85-e5-88-b0android%2F</url>
    <content type="text"><![CDATA[http://blog.csdn.net/yuxikuo_1/article/details/41746869 研究了N久+N次，终于在这一周解决了，感谢度娘。感觉第一次快要跑通时，心里真是万分紧张，感觉什么都不会再爱了。点下按钮，返回预期的值，OK。搞定，为此，放松了一个上午，现在来写写一些我是怎么搞通的吧。不敢保证，每个库都能这么搞，但是对一些刚入门者，应该有帮助。好的，开讲！ 1、研究背景与意义公司要单独封装网络库，所以，首先想到的libcurl，因为搞过半年Cocos2d-x，所以，直接找到了Cocos2d-x引擎源码的预编译第三方库里的libcurl。什么是预编译库？下面来解释解释。 1.1预编译库所谓预编译库其实就是静态库，是一种可执行代码的二进制形式，可以被操作系统载入内存执行。在Linux或Unix下是以.a结尾的库文件。库文件首先会进行编译，当我们把库文件导入自己的动态或静态文件或工程中时，会提高代码的编译速度。静态库在代码编译的时候是已经被载入可执行程序的，体积较大，动态库是在执行程序时才载入内存，在编译的过程中简单的引用，因此代码体积较小。这篇文章详细讲解了Linux下静态和动态库的基础知识。Linux库详解 1.2libcurlLibcurl是一个开源免费的库文件，客户端传输库，支持FTP、FTPS、TFTP、HTTP、HTTPS、GOPHER、TELENT、DICT、FILE、LDAP等，C语言编写，跨平台，支持Windows、Unix、Linux等，线程安全，支持Ipv6，易于使用。官网下载地址：http://curl.haxx.se/download.html官网API详解：http://curl.haxx.se/libcurl/c/其实主要是4个函数：1）curl_easy_init()初始化;2）curl_easy_setopt()设置属性;3）curl_easy_perform，连接。4）curl_easy_getinfo这篇文章详细介绍了如何使用libcurl将下载内容写入内存：http://blog.163.com/xu_chao2000/blog/static/27770610200801303252802/ 2、打包Android版libcurl包关于打包libcurl包，网上有非常多的教程，由于Cocos2d-x已经为我们提供了几乎大部分平台的预编译库，即.a文件。所以，这一步我就在这省略了，虽然可能网上的教程有的比较坑爹，不过，多花些时间，综合起来，就会凑成一个完美的解决方案。 3、开始打包在打包之前，我们可能需要学一下JNI和NDK编程的知识，不过，这些知识，也不是一篇两篇文章能解释清楚的，所以，这里也不打算讲解，有兴趣的可以翻看本人之前的博客，或者网上百度会有大篇大篇的文章。 3.1新建Android空工程使用Eclipse新建Android工程。1）由于Android本身新建工程并不包含jni目录，所以，我们需要自己添加该目录，并在该目录下添加两个文件。Android.mk和Application.mk这两个文件是ndk-build使用的文件。2）拷贝Cocos2d-x的预编译库。我们需要的libcurl预编译库在Cocos2d-x引擎cocos2d-x-3.3rc0/external/curl目录下，将该目录下的两个文件include和prebuilt拷贝到我们上一步新建的android工程中。3）删除include和prebuilt两个目录中android目录之外的的平台目录。因为我们用不到那些4）更新Eclipse，可以看到，我们刚才的操作过后的目录如下：重点是jni目录下的改变（网络限制，暂时传不上来照片） 3.2先来一个简单例子，抛砖引玉Android.mk文件可以说是本文最终要的一部分。我们先一步一步去讲一讲它。 首先阅读下这篇文章，预热一下，了解了解打包静态库和动态库的方法。 其次我们从NDK的samples的two-libs例子入手，分析mk的写法。（即搭建Android环境时，解压的NDK目录下的samples/two-libs） 先上代码 1）first文件：定义了一个加法的方法1234567891011121314//first.h #ifndef FIRST_H #define FIRST_H extern int first(int x, int y); #endif /* FIRST_H */ //first.c #include "first.h" int first(int x, int y) &#123; return x + y; &#125; 2）second.c：这个文件是Jni的相关的文件。123456789101112//second.c #include "first.h" #include &amp;lt;jni.h&amp;gt; //添加jni头文件 //下面这个函数的意思就是com.example.twolibs包com.example.androidlibcurldemo下MainActivity.java中的add方法。 jint Java_com_example_androidlibcurldemo_MainActivity_add( JNIEnv* env, jobject this, jint x, jint y ) &#123; return first(x, y); &#125; 这个add方法，是在我们上一步创建工程的src目录下的MainActivity.java中声明的两个native方法，说白了，second.c的作用就是，定义java中的native方法，并在实现中调用C的代码，如first.c中的first函数。相当于一个中介的样子。 3）Android.mk：例子中的Android.mk文件 #定义变量LOCAL_PATH指向mk所在的路径，如Android.mk文件在/usr/lib/curl/Android.mk #那么LOCAL_PATH代表的值就是：/usr/lib/curl #注意，这个变量没有清理，如果在后面引入其他mk文件，这个变量是可以传递到引入的mk文件中的 LOCAL_PATH:= $(call my-dir) first lib, which will be built statically#CLEAR_VARS清理变量，因为这些变量都是静态全局的，如果不清了，下次编译时用到这些变量就会造成错误的include $(CLEAR_VARS) #本地静态库模块名字，如果在别处导入库文件时，会用到这个名字 #此处名字的使用是libXXX.so或libXXX.a中的XXX的名字，也可以libXXX，不过，这两种在使用上还是有点区别的， #使用XXX或libXXX最后打包库后都是libXXX.a/so,在导入库模块时要使用LOCAL_LDLIBS := -lz来指明导入的是本地库 #否则会报找不到库的错误LOCAL_MODULE := libtwolib-firstLOCAL_SRC_FILES := first.c #创建静态库，注意，这个库是我们第一次创建，所以使用BUILD_STATIC_LIBRARY #如果LOCAL_SRC_FILES（即源码文件）使用的是.a则使用include $(PREBUILT_STATIC_LIBRARY)，见下面代码 #如果使用的是.so文件，则使用include $(PREBUILT_SHARED_LIBRARY)，PREBUILT表示使用的是预编译库里的源文件include $(BUILD_STATIC_LIBRARY) second lib, which will depend on and include the first one#清理变量include $(CLEAR_VARS) #模块名称LOCAL_MODULE := libtwolib-second #源码文件LOCAL_SRC_FILES := second.c #导入关联的静态库，如果还有其它静态库，直接在后面添加即可，注意空格隔开LOCAL_STATIC_LIBRARIES := libtwolib-first #最终创建动态库文件，libtwolib-second.so #如果最终创建静态库文件，是需要把SHARED改为STATIC即可，如libtwolib-firstinclude $(BUILD_SHARED_LIBRARY)4）Application.mk 我们在这个mk文件中只添加APP_ABI := all NDK就会为我们自动打包对应不同平台ABI的库文件，不同平台的库文件还是有区别的。 不过现在的Android手机大部分都是armeabi的，所以，如果不添加这句话，NDK默认的就会生成armeabi目录，并编译这个平台下使用的库文件。 5）编译库文件 我们进入到创建的Android工程，根目录即可，打开终端，如我使用的mac，打开终端后输入： $ cd /Users/yuxikuo/Android_WorkPlace/AndroidLibcurlDemo $ ndk-build Android NDK: WARNING: APP_PLATFORM android-19 is larger than android:minSdkVersion 8 in ./AndroidManifest.xml[armeabi] Compile thumb : twolib-second &lt;= second.c[armeabi] Compile thumb : twolib-first &lt;= first.c[armeabi] StaticLibrary : libtwolib-first.a[armeabi] SharedLibrary : libtwolib-second.so[armeabi] Install : libtwolib-second.so =&gt; libs/armeabi/libtwolib-second.so打包后的结果如上：Android中NDK将打包后的包文件拷贝到1）工程目录下的libs/下对应ABI目录下面，ABI表示当前机器的操作系统，一共有4类，不同的目标系统ABI有不同的打包方式和兼容性。2）同时还会在工程目录新建obj/local目录，该目录下同样根据不同的ABI拷贝对应的库文件。不过，不同的ABI目录是需要自己新建的，默认下是armeabi，因为大部分Android使用的是这个，并且它可以运行在所有ARM CPU上。 armeabi =&gt; ARMv5TE以上 armeabi-v7a =&gt; ARMv7以上 x86 =&gt; x86平台 mips =&gt; mips 由于根据不同的ABI进行打包，那么我们每次都会生成4个包，打包过程见下面代码。 而且现在其他的平台并不常见，而且armeabi对其他平台也有兼容，所以，我们这里暂时只考虑armeabi平台下库文件的打包。 Android NDK: WARNING: APP_PLATFORM android-19 is larger than android:minSdkVersion 8 in ./AndroidManifest.xml[armeabi-v7a] Compile thumb : twolib-second &lt;= second.c[armeabi-v7a] Compile thumb : twolib-first &lt;= first.c[armeabi-v7a] StaticLibrary : libtwolib-first.a[armeabi-v7a] SharedLibrary : libtwolib-second.so[armeabi-v7a] Install : libtwolib-second.so =&gt; libs/armeabi-v7a/libtwolib-second.so //armeabi-v7a[armeabi] Compile thumb : twolib-second &lt;= second.c[armeabi] Compile thumb : twolib-first &lt;= first.c[armeabi] StaticLibrary : libtwolib-first.a[armeabi] SharedLibrary : libtwolib-second.so[armeabi] Install : libtwolib-second.so =&gt; libs/armeabi/libtwolib-second.so //armeabi[x86] Compile : twolib-second &lt;= second.c[x86] Compile : twolib-first &lt;= first.c[x86] StaticLibrary : libtwolib-first.a[x86] SharedLibrary : libtwolib-second.so[x86] Install : libtwolib-second.so =&gt; libs/x86/libtwolib-second.so //x86[mips] Compile : twolib-second &lt;= second.c[mips] Compile : twolib-first &lt;= first.c[mips] StaticLibrary : libtwolib-first.a[mips] SharedLibrary : libtwolib-second.so[mips] Install : libtwolib-second.so =&gt; libs/mips/libtwolib-second.so //mips6）在Java代码中调用。 在MainActivity.java中添加如下代码1234567891011121314151617181920@Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); //super.onCreate(savedInstanceState); TextView tv = new TextView(this); int x = 1000; int y = 42; // here, we dynamically load the library at runtime // before calling the native method. //把生成的库load进来，注意去掉libXXX.so中的lib和so。只保留XXX System.loadLibrary("twolib-second"); int z = add(x, y); tv.setText( "The sum of " + x + " and " + y + " is " + z ); setContentView(tv); &#125; public native int add(int x, int y);//native函数声明，在我们的second.c文件中定义，并使用了first.c中的first函数，实现加法注意，如果出现错误或崩溃，看看second.c的函数包名是不是错误，然后看看有没有在java中声明native的add方法 截图稍后上传。 3.3重头戏:使用libcurl.a打包的so库到Android1）首先，看看我们之前拷贝到jni目录下的两个文件夹include和prebuilt。对了，这两个目录是我阉割的，把其它无关平台的目录删除了。 2）include目录下是libcurl.a库中源文件的头文件。我们也需要将它打包进包里面，才能在涉及到包时，自动引入头文件。 3）prebuilt目录是存放libcurl.a的目录，我们暂时保存Cocos2d-x的目录结构，这样，我们就免得修改下面的Android.mk文件了 4）/prebuilt/android目录下的Android.mk分析： 注意为了减少路径上的问题，我将include文件夹拷贝到了和该Android.mk文件相同的路径下了 LOCAL_PATHA:=$(call my-dir)//当前路径变量，注意，我在该处设置的变量名是LOCAL_PATHA，因为后面需要导入这个mk文件，防止变量冲突include $(CLEAR_VARS)//清理变量LOCAL_MODULE := cocos_curl_static //模块名称LOCAL_MODULE_FILENAME := curl //生成的包名LOCAL_SRC_FILES := prebuilt/android/$(TARGET_ARCH_ABI)/libcurl.a //依赖的源文件，注意：路径一定要为相对路径，这一块比较容易出错LOCAL_EXPORT_C_INCLUDES := $(LOCAL_PATHA)/include/android //为了能在库外面使用库的方法，需要引入头文件include $(PREBUILT_STATIC_LIBRARY)//预编译成静态库4）目录下的Android.mk分析： LOCAL_PATH:=$(call my-dir) #修改1include $(LOCAL_PATH)/prebuilt/android/Android.mk first lib, which will be built statically include $(CLEAR_VARS) LOCAL_MODULE := libtwolib-firstLOCAL_SRC_FILES := first.c include $(BUILD_STATIC_LIBRARY) second lib, which will depend on and include the first one include $(CLEAR_VARS) LOCAL_MODULE := libtwolib-secondLOCAL_SRC_FILES := second.c #修改2，尤其是-lz的作用，非常大LOCAL_C_INCLUDES := $(LOCAL_PATH)LOCAL_LDLIBS := -llog \ -lz #修改3，增加cocos_curl_static库的导入，这就是我们在上面mk定义的LOCAL_STATIC_LIBRARIES := libtwolib-first cocos_curl_static include $(BUILD_SHARED_LIBRARY)5）重写second.c，调用libcurl中的方法，进行网络请求 #include “first.h” #include &lt;jni.h&gt; #include &lt;curl/curl.h&gt; jintJava_com_example_androidlibcurldemo_MainActivity_add( JNIEnv env, jobject this, jint x, jint y ){ CURL curl; CURLcode res; curl = curl_easy_init(); if(NULL == curl)//如果初始化失败，返回1000 { return first(1,999); } curl_easy_setopt(curl, CURLOPT_URL,”http://www.baidu.com&quot;);//以get请求www.baidu.com curl_easy_setopt(curl, CURLOPT_READFUNCTION,NULL); curl_easy_setopt(curl, CURLOPT_NOSIGNAL,1); curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT,20);//连接时间，由于网络不好，为了达到测试效果，我设置的时间较长 curl_easy_setopt(curl, CURLOPT_TIMEOUT,20); res = curl_easy_perform(curl);//执行 curl_easy_cleanup(curl);//清除&lt;span style=”white-space:pre”&gt; &lt;/span&gt; return first(res,res);//根据res值返回到Android中的TextView中，如果res是0，表示请求成功，如果是6表示无法解析主机，即没联网}6）编译库文件 同样还是在终端中，先进入到Android工程目录，然后执行ndk-build。最终在obj和libs目录下生成了我们的libtwolib-second库 3.4如何使用库1）首先，还是要修改我们的MainActivity.java类，修改如下：123456789101112131415161718192021222324private Button button; private TextView tv; private int x = 123; private int y = 456; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // here, we dynamically load the library at runtime // before calling the native method. // System.loadLibrary("twolib-second"); tv = (TextView)findViewById(R.id.textView2); button = (Button) this.findViewById(R.id.button1); this.button.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View arg0) &#123; int z = add(x, y); tv.setText( "网络请求结果" + z ); &#125; &#125;); &#125; public native int add(int x, int y);&lt;/pre&gt; 我们要在activity_main布局中，添加一个按钮和一个TextView，按钮用于出发网络请求，TextView用于显示请求结果。 显示0表示请求成功。显示12表示无法解析主机，没联网。 2）在AndroidManifest.xml中添加网络权限。否则会在TextView显示12 &lt;uses-permission android:name=“android.permission.INTERNET”/&gt; 至此，我们就完成了库的编译和使用。 Ctrl+R 打包APK到手机，点击button测试吧。不过这是同步请求，异步暂时还未研究。 以上步骤是经过真机测试，截图如下：网络限制，稍后上传。 疑惑：打包时，如果我没有在second.c中引用&lt;curl/curl.h&gt;进行打包，包只有几十kb，引用后就1.2MB了，但是，我看了下libcurl.a的库本身就4点几MB，不知道什么原因，如有知道，烦请告知。参考资料： 1）http://blog.csdn.net/sozell/article/details/10551309 2）http://www.2cto.com/kf/201204/125939.html 3）http://jingyan.baidu.com/article/c910274bffa502cd361d2da0.html 4）http://blog.csdn.net/smfwuxiao/article/details/6591927 5）http://www.cnblogs.com/lyout/archive/2013/06/03/3115799.html 6）http://www.linuxidc.com/Linux/2012-07/66105.htm 7）http://blog.csdn.net/smfwuxiao/article/details/8523479 8）http://blog.csdn.net/yuxikuo_1/article/details/39577257 9）http://bbs.csdn.net/topics/370006153 10）http://blog.csdn.net/huyiyang2010/article/details/7664201 11）http://blog.csdn.net/cjj198561/article/details/33417965 12）http://bbs.chinaunix.net/thread-4096875-1-1.html]]></content>
      <categories>
        <category>Android</category>
        <category>Cocos2d</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>cocos2d</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用NDK自带的iconv进行编码转换]]></title>
    <url>%2F2017%2F03%2F03%2Fe4-bd-bf-e7-94-a8ndk-e8-87-aa-e5-b8-a6-e7-9a-84iconv-e8-bf-9b-e8-a1-8c-e7-bc-96-e7-a0-81-e8-bd-ac-e6-8d-a2%2F</url>
    <content type="text"><![CDATA[http://wty530.blog.51cto.com/3238860/1852579 cocos2d-x显示中文乱码最常用的解决方式主要有xml文件读取、使用iconv库。由于在使用iconv库出现了比较多的问题，这里作个总结，给后来人少走一些弯路。 我用的是cocos2d-x 3.4的版本，我也是参照网上的教程，但可能一些细节教程里面没有提到，这里就详细列出来。 1、在cocos2d-x端新建一个ChineseString.h文件1234567891011121314151617181920212223242526272829303132333435363738394041#ifndef __ChineseString_H__#define __ChineseString_H__#if (CC_TARGET_PLATFORM == CC_PLATFORM_ANDROID)#include "../../../software/android-ndk-r10e/sources/android/support/include/iconv.h"#endif#if (CC_TARGET_PLATFORM == CC_PLATFORM_WIN32)#include "external/win32-specific/icon/include/iconv.h"#endif#include &amp;lt;string&amp;gt;#pragma comment(lib, "libiconv.lib")static char g_GBKConvUTF8Buf[5000] = &#123;0&#125;;class ChineseString&#123;public:static const char* GBKToUTF8(char *strChar)&#123;iconv_t iconvH;iconvH = iconv_open("utf-8", "gb2312");if(iconvH == 0)&#123;return NULL;&#125;size_t strLength = strlen(strChar);size_t outLength = strLength * 4;size_t copyLength = outLength;memset(g_GBKConvUTF8Buf, 0, 5000);char* outbuf = (char*)malloc(outLength);char* pBuff = outbuf;memset(outbuf, 0, outLength);if (-1 == iconv(iconvH, &amp;amp;strChar, &amp;amp;strLength, &amp;amp;outbuf, &amp;amp;outLength)) &#123; iconv_close(iconvH); return NULL; &#125; memcpy(g_GBKConvUTF8Buf,pBuff,copyLength); free(pBuff); iconv_close(iconvH); return g_GBKConvUTF8Buf;&#125;&#125;;#endif 2、Android端 网上有一种方法要自己下载iconv库，我觉得那种方法挺麻烦的，而且我自己跟着步骤试了下，没有成功，后面放弃了，最后又找了一种方法，也就是下面要介绍的用NDK自带的iconv库。 我用的是android-ndk-r10e，可以发现有个iconv.h文件，也就是上面cocos2d-x端代码里引用的路径 #if (CC_TARGET_PLATFORM == CC_PLATFORM_ANDROID)#include “../../../software/android-ndk-r10e/sources/android/support/include/iconv.h”#endif这个根据自己ndk存放的路径做调整。然后修改proj.android/jni目录下的Android.mk文件主要加了LOCAL_STATIC_LIBRARIES += android_support$(call import-module, android/support)在相应的地方加入这两段代码做了以上这些步骤，正常情况下是可以通过了。注意以下几点：1、android编译碰到如下错误invalid conversion from ‘const char‘ to ‘char‘这是由于我们定义GBKToUTF8这个函数时，参数使用const char strChar,然后传入iconv函数时ndk的iconv.h定义的是size_t iconv(iconv_t, char**, size_t, char*, size_t); 所以只需要把const去掉就ok了。2、网上有介绍说ndk r9的iconv.h代码有问题，需要修改如下，大家注意一下就行，r10是没有这个问题12345//将#ifdef __cplus_plus //改为 #ifdef __cplusplus &#125; // extern "C" #endif&nbsp;]]></content>
      <categories>
        <category>Cocos2d</category>
      </categories>
      <tags>
        <tag>game</tag>
        <tag>cocos2d</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android NDK环境搭建]]></title>
    <url>%2F2017%2F02%2F27%2FAndroid-NDK%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[http://jingyan.baidu.com/article/5d6edee22d908799eadeec9f.html 使用最新ndk，直接抛弃cygwin，以前做Android的项目要用到NDK就必须要下载NDK，下载安装Cygwin(模拟Linux环境用的)，下载CDT（Eclipse C/C++开发插件），还要配置编译器，环境变量，特别麻烦，新版就不需要了## 工具/原料* ADT NDK &lt;/div&gt; ## 方法/步骤1. 1Android官网下载Android的开发工具ADT(Android Development Tool的缩写)，该工具集成了最新的ADT和NDK插件以及Eclipse，还有一个最新版本SDK。解压之后就可以用了 2 ADT插件：管理Android SDK和相关的开发工具的 NDK插件：用于开发Android NDK的插件，ADT版本在20以上，就能安装NDK插件，另外NDK集成了CDT插件 下载链接见：http://developer.android.com/sdk/index.html &lt;/div&gt; 3 Android官网下载最新的NDK，注：NDK版本在r7以上之后就集成了Cygwin，而且还是十分精简版。 下载链接见：http://developer.android.com/tools/sdk/ndk/index.html &lt;/div&gt; END## eclipse配置1. 打开Eclipse，点Window-&gt;Preferences-&gt;Android-&gt;NDK,设置NDK路径，例如Shamoo的是E:\android-ndk-r9c 新建一个Android工程，在工程上右键点击Android Tools-&gt;Add Native Support&#8230;,然后给我们的.so文件取个名字，例如:my-ndk &lt;/div&gt; 这时候工程就会多一个jni的文件夹，jni下有Android.mk和my-ndk.cpp文件。Android.mk是NDK工程的Makefile，my-ndk.cpp就是NDK的源文件。 &lt;/div&gt; 接下来仿着NDK的demo,Hello-JNI工程写一下。使用Alt + &#8216;/&#8217;可以代码提示！很爽！有木有？之前用CDT时候死活都按不出代码提示，郁闷&#8230; &lt;/div&gt; JNI接口的命名规范是：Java + 调用该方法的包名(包名的点用代替) + + 调用该接口的类名 + + 方法名，对于实例方法，有两个参数是必要的，一个JNI的环境指针JNIEnv * &lt;/div&gt; 完成了，然后运行。运行之前先编译NDK，然后在编译JAVA代码。编译也许会遇到Unable to launch cygpath. Is Cygwin on the path?如何解决？如下 &lt;/div&gt; 工程右键，点Properties-&gt;C/C++ Build的Building Settings中去掉Use default build command，然后输入${NDKROOT}/ndk-build.cmd &lt;/div&gt; 在C/C++ Build中点击Environment，点Add&#8230;添加环境变量NDKROOT，值为NDK的根目录 &lt;/div&gt; END经验内容仅供参考，如果您需解决具体问题(尤其法律、医学等领域)，建议您详细咨询相关领域专业人士。举报作者声明：本篇经验系本人依照真实经历原创，未经许可，谢绝转载。]]></content>
      <tags>
        <tag>Android</tag>
        <tag>android</tag>
        <tag>ndk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[更好的安装软件的方法（Windows：Chocolatey，Mac：Homebrew）]]></title>
    <url>%2F2017%2F02%2F26%2Fe6-9b-b4-e5-a5-bd-e7-9a-84-e5-ae-89-e8-a3-85-e8-bd-af-e4-bb-b6-e7-9a-84-e6-96-b9-e6-b3-95-ef-bc-88windows-ef-bc-9achocolatey-ef-bc-8cmac-ef-bc-9ahomebrew-ef-bc-89%2F</url>
    <content type="text"><![CDATA[https://ninghao.net/blog/2071 你决定要把 Web 当成自己的事业，并且已经开始学习了。你听到的，看到的，或者自己感觉的，很可能是错的。一开始，我们就用更好的方法去学习与做事，会节省很多时间，也能减轻痛苦。找不到方向，不知道从哪里下手，今天就跟宁皓一起，一切都在这里开始：） 遇到的问题学习 Web 设计与开发得去安装很多软件，Git，Node，Ruby，Virtualbox，Vagrant，Atom，Brackets，Chrome… 有些软件是你要直接用的，有些是其它软件所依赖的。安装这些东西，你得先找到它们的官方网站，然后下载适合自己系统的版本，双击安装，Next，Next，下一步，下一步 … 完成！安装完以后，你发现还不能用，因为你不知道这个软件还需要你去安装一个其它的东西。 解决的方法正确的做法是使用包管理工具（Package Manager）去管理这些软件，这里说的是操作系统级别的包管理工具，也就是管理想要安装到操作系统上的软件的工具。在以后，你还会听到项目级别的包管理，比如前端项目用的 Bower ，还有管理 NodeJS 包的 npm 。 包管理工具，可以让我们用几个简单的命令去安装，升级，还有删除软件，并且它会自动给我们解决软件之间的依赖的问题。 Windows 用户可以使用 Chocolatey 这个包管理工具，Mac 用户可以使用 Homebrew 。 连接不上…在下载东西的时候，如果出现网络连接的错误，一般就是 “网络问题”，给宽带服务商打电话没有用，你得自己准备 “梯子”。 ChocolateyWindows 需要安装一下 Chocolatey，然后再用 Chocolatey 去管理需要安装到系统上的软件，这些可以安装的软件叫做包（ Package ）。 在命令行工具下面安装 Chocolatey，通过命令提示符（cmd），或者 Powershell。 choco search 去搜索想要的包，用 -all 参数会显示所有可用的版本。 choco install 安装包，用 -version 参数可以安装指定版本的包。 choco upgrade 把安装的包升级成最新的版本。 choco uninstall 从电脑上删除已经安装的包，删除前用 choco version 命令查看指定包的是否有可用的更新。 安装 Chocolatey安装 Chocolatey，只需要在 Windows 系统的命令行工具下面去执行一行命令，这个命令行工具可以是 命令提示符（cmd），也可以是 Powershell ，只需要在其中的一个上面安装 Chocolatey 就可以了。你要用管理员的身份去运行命令行工具，不然会遇到权限问题。 以管理员身份打开命令行工具Windows 7：点击 开始 菜单，在搜索框里输入 cmd 或者 powershell ，找到以后，用鼠标右键点击它们，选择 以管理员身份运行。 Windows 8 + ：使用快捷键 win + Q ，搜索 cmd 或者 powershell ，然后右键点击它们，在窗口下面，选择 以管理员身份运行。 在 命令提示符 上安装 Chocolatey@powershell -NoProfile -ExecutionPolicy unrestricted -Command “iex ((new-object net.webclient).DownloadString(‘https://chocolatey.org/install.ps1‘))” &amp;&amp; SET PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin 在 Powershell 上安装 Chocolateyiex ((new-object net.webclient).DownloadString('https://chocolatey.org/install.ps1')) ** 提示：**如果是在 Powershell 下面安装 Chocolatey 之前，先修改一下 Powershell 的执行策略，不然会出现 “此系统中禁止执行脚本” 这样的错误，解决的方法是执行下面的命令，意思就是把执行的策略设置成不限制： Set-ExecutionPolicy unrestricted 测试 在命令行工具的下面，输入： choco help 如果出现一些有用的帮助信息，比如 Chocolatey 的版本号，安装到的目录，相关的命令，还有示例等等，这就说明我们已经可以在系统上使用 Chocolatey 了。 ### 使用 Chocolatey 用 Chocolatey 做的事都是通过在命令行工具里面输入命令去做的，查看这些命令可以在使用 choco help 这个命令，Chocolatey 的命令都是用 choco 开头，后面接着是更具体的子命令，比如 install 就是去安装点什么，update 是去升级指定的包，uninstall 是把包从电脑上删除掉。 #### 搜索 在 Chocolatey 的官方网站上（[https://chocolatey.org/packages](https://chocolatey.org/packages)），可以查看所有可以使用 Chocolatey 安装的东西，或者也可以在命令行工具的下面去搜索想要安装的东西： choco search &lt;keyword&gt; 跟 search 命令功能类似的还有 list 命令： choco list &lt;keyword&gt; 比如搜索一下 nodeJS 相关的包，可以这样： choco search nodeJS 上面的命令会在返回所以跟 nodeJS 相关的包，想要查看这些包所有的可用的版本，可以在命令的后面加上一个 -all 参数： choco search nodeJS **-all** 包的类型 （例：nodejs，git） *.install （例：nodejs.install，git.install） *.commandline（例：nodejs.commandline，未来会被抛弃） *.portable（例：putty.portable）Chocolatey 的包有不同的类型，有些包的名字里面会包含特殊的后缀，比如 .install ，.commandline，.portable ，有些包的名字不带这些后缀。 安装带 .install 后缀的包，这个包会出现在系统控制面板里的 卸载或更改程序 里面，你可以把 .install 的包想成是通过安装程序（msi）安装的包。 .commandline（未来会被抛弃） 与 .portable 后缀的包是压缩包（zip），安装这种后缀的包，你不能在 卸载或更改程序 里找到它们。 你也可以选择不带后缀的包，这样如果系统中已经安装了这个包，就会跳过去，如果没安装，Chocolatey 就会为你安装一个，默认安装的这个包的类型应该就是 .install 后缀的包。 安装安装包，用的是 choco install 命令，把想要安装的包的名字放到 install 的后面，想一次去安装多个包，可以在 install 命令后面添加一个包的名字的列表，不同的包之间用空格分隔开。 choco install &lt;package1 package2 package3...&gt; 比如我们想去安装一个 cURL 工具，安装之前可以先用 search 命令搜索一下，搜索的时候加上 -all 参数，会显示出包的所有可用的版本，在安装的时候，你可以在 -version 参数的后面，指定一个具体要安装的版本，不使用 -version 参数，直接安装会安装包的最新发布的版本。 choco search curl -all 会返回一个列表： ... curl 7.21.7 curl 7.22.0 curl 7.23.1 curl 7.25.0 curl 7.28.1 ... 下面我们故意去安装一个旧版本的 curl ， 一会儿再去升级一下它。比如我要安装的是 7.22.0 版本的 curl ： choco install curl -version 7.22.0 Chocolatey 不仅可以给我们安装指定版本的包，它还能解决包的依赖问题，也就是，如果你安装的这个包需要其它的包提供的功能，Chocolatey 会自动给你安装这个依赖的包。 安装以后，可以用 choco list 命令，加上一个 -localonly 或 -lo（简写形式） 参数，查看在本地安装的包的列表。 choco list -localonly 升级升级安装在本地电脑上的包，用的是 choco upgrade 命令，后面加上要升级的包的名字： choco upgrade &lt;package&gt; 在升级包之前，可以先先去查看一下有没有可用的升级。如果你想查看 Chocolatey 本身有没有可用的升级，执行命令： choco version 在 choco version 命令的后面，输入具体的包的名字，可以查看指定的这个包有没有可用的新版本。比如查看一下前面我们安装的 cURL 这个小东西的升级： choco version curl 返回的结果看起来是这样的： name : curl found : 7.22.0 ... latest : 7.28.1 ... name 对应的是包的名字，found 后面是安装在本地电脑上的版本，latest 后面是最新的可用的版本。这里 cURL 这个包的最新版本是 7.28.1 ，比我们安装的版本要新，所以可以去升级一下它。 choco upgrade curl cURL 是一个命令行工具，所以在命令行工具的下面，查看这个小工具的版本可以这样： curl -version 上面命令会返回当前安装在电脑上的 cURL 的版本，你会发现，它已经被 Chocolatey 升级成最新的版本了。 #### 删除 想要删除掉用 Chocolatey 安装的包，用的是 choco uninstall ，后面加上要卸载或者删除掉的包的名字。 choco uninstall &lt;package&gt; 在删除包之前，可以查看一下所有安装在本地的包的列表： choco list -localonly 比如我们要删除掉之前安装的 cURL 这个包： choco uninstall curl 成功以后，再查看一下安装在本地的包的列表，已经看不到 cURL 了。 ## Homebrew Mac 上面有 App Store，它像是一个图形界面的包管理工具，也可以很方便的管理系统上的软件。不过很多软件你是在 App Store 上面找不到的，所以，可以通过 Homebrew 这个包管理工具，在命令行下面去管理软件。这些能够使用 Homebrew 安装的东西叫做 Package，在 Homebrew 里面，Package 还有个名字叫 Formula 。 * 在终端上执行安装 Homebrew 的命令。 * man brew 可以查看 brew 命令的使用手册。 * brew search 去搜索一下想要安装的东西。 * brew install 可以安装指定的包。 * brew upgrade 可以升级包。 * brew remote 删除掉不需要的包。 ### 安装 Homebrew 打开 Mac 自带的终端，可以在 Launchpad（F4）里面搜索 Terminal（终端），然后执行下面的命令： ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 安装完成以后，执行 brew help，如果返回一些有用的帮助信息，说明可以在我们的电脑上使用 Homebrew 去管理软件了。 brew help 使用 HomebrewHomebrew 的命令都是用 brew 开头，后面接着是具体的命令。比如 brew help 可以查看帮助信息，brew install 可以去安装包，brew upgrade 可以升级已经安装的包。 查看使用手册要查看 Homebrew 所有可用的命令还有帮助的信息，在终端上执行 man brew 这条命令，man 就是 manpage （参考页），在 man 命令后面加上要查看使用手册的命令的名字。 man brew 要显示的内容如果很多，就会分页显示，有几个按键可以去浏览这些内容： * f 向后翻页 * b 向前翻页 * q 退出显示 #### 搜索 搜索可以使用 Homebrew 安装的东西，用的是 brew search，后面加上搜索的关键词。 brew search &lt;keyword&gt; 比如搜索一下 tree 这个小工具： brew search tree 上面的命令会列出包含 tree 这个关键词的包，要查看某个包的所有可用的版本，可以使用 brew versions，后面加上包的名字，像这样： brew versions tree > brew versions 不在被支持了，可以使用：[https://github.com/Homebrew/homebrew-versions](https://github.com/Homebrew/homebrew-versions) 访问这个包的主页可以使用 brew home 这个命令，再加上包的名字，这样可以在浏览器中打开包的主页： brew home tree 安装安装包用的是 brew install ，一般用 Homebrew 安装的东西都是一些命令行的工具，这些工具大部分都是开发的时候要用的，不过你会看到一些 Cask 开头的包，Cask 扩展了 Homebrew ，它可以让我们用 Homebrew 去安装一些带图形界面的软件，比如 Chrome 浏览器。 brew install &lt;package&gt; 下面我们用这个命令去安装一个叫 tree 的小工具： brew install tree 完成以后，在终端上输入： tree --help 如果你能看到一些有用的帮助信息，说明已经可以使用 tree 这个工具了。想查看一下使用 brew 安装的东西，输入： brew list 在返回的安装的包的列表里，你应该可以找到刚才用 brew install 安装的 tree 。 #### 升级 升级 Homebrew 本身，用的是 brew update 命令，如果你要升级的是已经安装的包，可以使用 brew upgrade，后面不加具体的要升级的包，Homebrew 会去升级所有的包，也可以在后面指定某个要升级的包。 brew upgrade &lt;package&gt; 比如去升级一下上面安装的 tree，可以先看一下这个包有没有可用的更新。 brew outdated 如果有，就可以去升级一下它： brew upgrade tree 删除删除使用 Homebrew 安装的包，用的是 brew remove ，后面加上要删除的包的名字。 brew remove &lt;package&gt;路径 Chocolatey Homebrew]]></content>
      <categories>
        <category>ide</category>
      </categories>
      <tags>
        <tag>choco</tag>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LibGDX教程——重建Flappy Bird——(6) 碰撞检测及细节处理]]></title>
    <url>%2F2017%2F02%2F24%2FLibGDX%E6%95%99%E7%A8%8B%E2%80%94%E2%80%94%E9%87%8D%E5%BB%BAFlappy-Bird%E2%80%94%E2%80%94-6-%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B%E5%8F%8A%E7%BB%86%E8%8A%82%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[http://blog.csdn.net/artzok/article/details/50570981 本章源码链接：Libgdx重建FlappyBird密码：twy2上一章完整的介绍了BOX2D的物理仿真创建过程，在本章我们将继续完成BOX2D的剩余内容——碰撞检测。因为BOX2D帮我们完成了所有物理模拟过程，包括碰撞检测，这极大的降低我们的项目难度，我们不需要理解碰撞检测如何运行，甚至不需要知道任何碰撞检测算法，就能够完成碰撞检测并通知我们。下面就让我们为FlappyBird添加碰撞检测的回调函数和相应的逻辑代码。碰撞检测 打开WorldController类，并为其添加下面代码：12345678910111213141516171819202122public class WorldController extends InputAdapter implements Disposable &#123; ... private void initWorld() &#123; if(world != null) world.dispose(); world = new World(new Vector2(0, -110.8f), false); // 为world添加碰撞检测监听器 world.setContactListener(new BirdContactListener()); &#125; ... private void collisionDetection(AbstractGameObject a, AbstractGameObject b) &#123; &#125; // 碰撞检测监听器 private class BirdContactListener implements ContactListener &#123; @Override public void beginContact(Contact arg0) &#123; AbstractGameObject a = (AbstractGameObject)arg0.getFixtureA().getBody().getUserData(); AbstractGameObject b = (AbstractGameObject)arg0.getFixtureB().getBody().getUserData(); collisionDetection(a, b); &#125; @Override public void endContact(Contact arg0) &#123;&#125; @Override public void postSolve(Contact arg0, ContactImpulse arg1) &#123;&#125; @Override public void preSolve(Contact arg0, Manifold arg1) &#123;&#125; &#125;首先定义一个BirdContactListener类，该类实现了ContactListener接口的四个方法，beginContact()和endContact()分别在开始碰撞(重叠)和结束碰撞时调用。preSolve()方法在碰撞检测之后，解决碰撞之前调用，你可以实现该方法替代BOX2D内置的碰撞处理方式；最后一个postSolve()方法在碰撞发生后调用，该方法是获得碰撞冲量的地方。这里只使用了一个方法beginContact()，该方法内首先通过Contact获得两个碰撞对象的Fiture然后再获得Body对象，因为创建Body时调用setUserData()方法将游戏对象本身作为用户数据，所有这里我们便可直接通过getUserData()获得游戏对象。最后调用WorldController()私有方法collisionDetection()处理碰撞事件。 在初始化函数init()中创建了一个BirdContactListener对象并调用World.setContactListener()为world设置了碰撞监听器。 根据上述添加的代码可以推断，一旦发生碰撞，collisionDetection()方法就会被调用，现在我们需要考虑在collisionDetection做什么？我们知道，FlappyBird游戏非常简单，一旦发生碰撞，游戏就即将结束，所以这里我们应该通知WorldController和Bird发生了碰撞，游戏需要马上结束。WorldController收到碰撞消息应该立马停止BOX2D模拟，Bird收到消息应该开始完成结束动画。 接下来，首先修改Bird对象：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Bird extends AbstractGameObject &#123; ... protected static final float DIED_DROP_DRAG = 0.5f; // 死亡后下落速度 ... private boolean contacted; private boolean flashed; ... // 初始化 public void init(int selected) &#123; contacted = false; flashed = false; ... &#125; ... // 通知碰撞事件 public void contact() &#123; contacted = true; &#125; public boolean isContact() &#123; return contacted; &#125; ... @Override public void render(SpriteBatch batch) &#123; // 如果发生碰撞则不再播放帧动画 if(!contacted) &#123; animDuration += Gdx.graphics.getDeltaTime(); currentFrame = birdAnimation.getKeyFrame(animDuration); &#125; // 发生碰撞但游戏还没有结束时小鸟要进行落地动画 else &#123; position.y -= DIED_DROP_DRAG; rotation -= BIRD_FLAP_ANGLE_POWER; position.y = Math.max(position.y, Land.LAND_HEIGHT - Constants.VIEWPORT_HEIGHT / 2 + dimension.y / 2); rotation = Math.max(rotation, BIRD_MAX_DROP_ANGLE); &#125; batch.draw(currentFrame.getTexture(), position.x - dimension.x / 2, position.y - dimension.y / 2, dimension.x / 2, dimension.y / 2, dimension.x, dimension.y, scale.x, scale.y, rotation, currentFrame.getRegionX(), currentFrame.getRegionY(), currentFrame.getRegionWidth(), currentFrame.getRegionHeight(), false, false); if (contacted &amp;amp;&amp;amp; !flashed) &#123; flashed = true; float w = Gdx.graphics.getWidth(); float h = Gdx.graphics.getHeight(); batch.draw(Assets.instance.decoration.white, -w / 2, -h / 2, w, h); &#125; &#125;&#125;首先添加了一个DIED_DROP_DRAG表示小鸟发生碰撞之后的下落速度，然后添加了两个boolean类型变量，其中contacted表示小鸟是否发生碰撞，flashed表示是否完成碰撞后的闪烁。后面我们添加了两个方法分别用于设置和获得contacted变量。变化最大的就是render()方法，通过对代码分解便可理解，如果没有发生碰撞，则一切正常执行，如果发生碰撞，则保持最后一次获得的动画帧不在更新，接着根据DIED_DROP_DRAG下降速度更新小鸟的y坐标，并根据BIRD_FLAP_ANGLE_POWER旋转速度更新小鸟的旋转角度，最后限定y坐标和rotation的最小值。render()方法最后还根据contacted和flashed完成闪烁过程，闪烁原理其实很简单，一旦发生碰撞我们就是用白色图片填充场景一帧即可。 接下来修改WorldController：12345678910111213141516public class WorldController extends InputAdapter implements Disposable &#123; ... public void update(float deltaTime) &#123; if(bird.isContact()) return; ... &#125; ... private void collisionDetection(AbstractGameObject a, AbstractGameObject b) &#123; if (a instanceof Bird) &#123;((Bird) a).contact(); else if (b instanceof Bird) &#123;((Bird) b).contact(); Gdx.app.debug(TAG, "Player Character Contected!"); &#125; ...&#125;首先在update()方法中测试bird对象是否发生碰撞，如果发生碰撞则不在跟新。接着修改collisionDetection()方法，一旦发生碰撞则通知Bird对象。游戏结束根据前面的分析我们可以确定，当Bird发生碰撞后，游戏并没有立即结束，还要进行结束前的一些动画(如果闪烁、降落)过程。接下来我们将为游戏添加结束过程。首先我们要确定游戏结束的条件。根据前面分析，当Bird对象发生碰撞后，需要完成下落动画才能结束游戏，因此游戏结束的标志就是小鸟已经完成下落动画，即小鸟的y轴坐标到达了地面且旋转角度rotation等于了-90度，所以为Bird添加判断是否游戏结束方法isGameOver()：123456public boolean isGameOver() &#123; return contacted &amp;amp;&amp;amp; (position.y &amp;lt;= Land.LAND_HEIGHT - Constants.VIEWPORT_HEIGHT / 2 + dimension.y / 2) &amp;amp;&amp;amp; (rotation == BIRD_MAX_DROP_ANGLE);&#125;接下来为WorldController添加一个boolean类型变量isGameOver，然后在update()中判断游戏是否结束：12345678910111213141516171819202122public class WorldController extends InputAdapter implements Disposable &#123; ... public boolean isGameOver; public WorldController() &#123; init(); &#125; private void init() &#123; ... isStart = false; isGameOver = false; ... &#125; ... public void update(float deltaTime) &#123; if(!isGameOver) &#123; isGameOver = bird.isGameOver(); &#125; if(bird.isContact()) return; ... &#125; ...&#125;既然游戏结束了那么游戏就可以重新启动。下面修改WorldController.touchDown()方法让游戏可以重新开始：123456789101112131415@Override public boolean touchDown(int screenX, int screenY, int pointer, int button) &#123; if (button == Buttons.LEFT) &#123; if(!isStart) &#123; isStart = true; bird.beginToSimulate(world); land.beginToSimulate(world); &#125; if(isGameOver) &#123; init(); &#125; bird.setJumping();&#125;return true; &#125;上述代码判断，当鼠标按下或发生触摸屏幕事件，我们判断游戏是否结束，如果结束则调用init()重新开始。但是要让上面修改可以正常启动，我们还必须作出重大修改： 首先为AbstractGameObject添加init()方法，并将构造函数的所有内容移入该方法内：12345678910public AbstractGameObject() &#123;&#125;public void init() &#123; position = new Vector2(); dimension = new Vector2(1, 1); origin = new Vector2(); scale = new Vector2(1, 1); rotation = 0; body = null;&#125;接着修改三个对象的init()方法，分别保证对父类的init()方法调用：123456789101112131415161718192021222324public Bird() &#123; init((int) (Math.random() * 3));&#125;// 初始化public void init(int selected) &#123; super.init(); ... &#125; public Land() &#123; ... init();&#125;public void init() &#123; super.init(); ...&#125; public Pipe() &#123; ... init();&#125;public void init() &#123; super.init(); ...&#125;现在我们就可以测试应用了： 现在我们已经完成了游戏的一个完整过程，并且可以重新启动，但是还缺少许多GUI和开始结束信息。这些内容将在下一章介绍。现在让我们来处理一个细节，因为在运行过程中每经过一定时间就会创建一个Pipe，而Pipe对象包含一个Body对象，所以如果当一个Pipe对象不在需要的时候我们不及时释放对应的Body对象，时间一长将大大降低BOX2D的运行效率，所以我们需要修改Pipes和Pipe类，使得运行更佳流畅。 细节处理 经过上述分析，我们修改Pipes类：1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Pipes extends AbstractGameObject &#123; ... private void testPipeNumberIsTooLarge(int amount) &#123; if (pipes != null &amp;amp;&amp;amp; pipes.size &amp;gt; amount) &#123; pipes.get(0).destroy(); pipes.removeIndex(0); &#125; &#125; ... public class Pipe extends AbstractGameObject &#123; ... @Override public void beginToSimulate(World world) &#123; // down BodyDef bodyDef = new BodyDef(); bodyDef.type = BodyType.KinematicBody; bodyDef.position.set(position); body = world.createBody(bodyDef); PolygonShape shape = new PolygonShape(); shape.setAsBox(dimension.x / 2, dnPipeHeight / 2, new Vector2(dimension.x / 2, dnPipeHeight / 2), 0); shape.setRadius(-0.1f); FixtureDef fixtureDefDown = new FixtureDef(); fixtureDefDown.shape = shape; body.createFixture(fixtureDefDown); body.setLinearVelocity(PIPE_VELOCITY, 0); // up float height = dimension.y - dnPipeHeight - CHANNEL_HEIGHT; shape.setAsBox(dimension.x / 2, height / 2, new Vector2(dimension.x / 2, dnPipeHeight + CHANNEL_HEIGHT + height / 2), 0); shape.setRadius(-0.1f); FixtureDef fixtureDefUp = new FixtureDef(); fixtureDefUp.shape = shape; body.createFixture(fixtureDefUp); &#125; public void destroy() &#123; for(Fixture fixture : body.getFixtureList()) &#123; body.destroyFixture(fixture); &#125; Pipes.this.word.destroyBody(body); &#125; ... &#125;&#125;首先看一下Pipe内部类，我们修改了beginToSimulate()的实现原理，之前我们是为每个Pipe维护两个Body对象，这样处理其实完全可以，但是BOX2D的Body对象具有支持多Fixtue特性，所以我们完全没有必要创建两个Body，因为我们之后还需要释放Body和Fixtue对象，所以创建一个Body对象更利于管理。接下来我们为Pipe添加了destroy()方法，我们在该方法内销毁了body的所有Fixture对象和Body对象本身。 接下来看看Pipes对象的testPipeNumberIsTooLarge()，在该方法我们内测试如果Pipe对象的数量过大，则销毁一个Pipe对象相应的Body和Fixture对象。接下来我们测试应用： 现在是不是发现游戏流畅了许多！如果你觉得Bird的下降速度太慢，难度较小可以修改一下WorldController.initWorld()方法，将world对象的重力加速度修改大一些。我这里是world = new World(new Vector2(0, -110.8f), false)这里还可以调节。 本章我们创建了碰撞检测逻辑以及处理一些细节问题，下一章我们将为游戏添加分数、帧率、各种按钮等等GUI信息。]]></content>
      <tags>
        <tag>libgdx</tag>
        <tag>game</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git使用教程]]></title>
    <url>%2F2017%2F02%2F19%2Fgit-e4-bd-bf-e7-94-a8-e6-95-99-e7-a8-8b%2F</url>
    <content type="text"><![CDATA[http://www.cnblogs.com/tugenhua0707/p/4050072.html Git使用教程 一：Git是什么？ Git是目前世界上最先进的分布式版本控制系统。 二：SVN与Git的最主要的区别？ SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就纳闷了。 Git是分布式版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。 三：在windows上如何安装Git？ msysgit是 windows版的Git,如下： ![](http://images.cnitblog.com/blog/561794/201410/251338547302114.jpg) 需要从网上下载一个，然后进行默认安装即可。安装完成后，在开始菜单里面找到 “Git –&gt; Git Bash”,如下： 会弹出一个类似的命令窗口的东西，就说明Git安装成功。如下： 安装完成后，还需要最后一步设置，在命令行输入如下： 因为Git是分布式版本控制系统，所以需要填写用户名和邮箱作为一个标识。 注意：git config –global 参数，有了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然你也可以对某个仓库指定的不同的用户名和邮箱。 四：如何操作？ 一：创建版本库。 什么是版本库？版本库又名仓库，英文名repository,你可以简单的理解一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改，删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻还可以将文件”还原”。 所以创建一个版本库也非常简单，如下我是D盘 –&amp;gt; www下 目录下新建一个testgit版本库。 pwd 命令是用于显示当前的目录。 1\. 通过命令 git init 把这个目录变成git可以管理的仓库，如下： 这时候你当前testgit目录下会多了一个.git的目录，这个目录是Git来跟踪管理版本的，没事千万不要手动乱改这个目录里面的文件，否则，会把git仓库给破坏了。如下： ![](http://images.cnitblog.com/blog/561794/201410/251343384492003.png) 2\. 把文件添加到版本库中。 首先要明确下，所有的版本控制系统，只能跟踪文本文件的改动，比如txt文件，网页，所有程序的代码等，Git也不列外，版本控制系统可以告诉你每次的改动，但是图片，视频这些二进制文件，虽能也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是知道图片从1kb变成2kb，但是到底改了啥，版本控制也不知道。 下面先看下**demo**如下演示： 我在版本库testgit目录下新建一个记事本文件 readme.txt 内容如下：11111111 第一步：使用命令 git add readme.txt添加到暂存区里面去。如下： ![](http://images.cnitblog.com/blog/561794/201410/251344226375669.png) 如果和上面一样，没有任何提示，说明已经添加成功了。 第二步：用命令 git commit告诉Git，把文件提交到仓库。 现在我们已经提交了一个readme.txt文件了，我们下面可以通过命令git status来查看是否还有文件未提交，如下： 说明没有任何文件未提交，但是我现在继续来改下readme.txt内容，比如我在下面添加一行2222222222内容，继续使用git status来查看下结果，如下： 上面的命令告诉我们 readme.txt文件已被修改，但是未被提交的修改。 接下来我想看下readme.txt文件到底改了什么内容，如何查看呢？可以使用如下命令： git diff readme.txt 如下： 如上可以看到，readme.txt文件内容从一行11111111改成 二行 添加了一行22222222内容。 知道了对readme.txt文件做了什么修改后，我们可以放心的提交到仓库了，提交修改和提交文件是一样的2步(第一步是git add 第二步是：git commit)。 如下： 二：版本回退： 如上，我们已经学会了修改文件，现在我继续对readme.txt文件进行修改，再增加一行 内容为33333333333333.继续执行命令如下： 现在我已经对readme.txt文件做了三次修改了，那么我现在想查看下历史记录，如何查呢？我们现在可以使用命令 git log 演示如下所示： git log命令显示从最近到最远的显示日志，我们可以看到最近三次提交，最近的一次是,增加内容为333333.上一次是添加内容222222，第一次默认是 111111.如果嫌上面显示的信息太多的话，我们可以使用命令 git log –pretty=oneline 演示如下： 现在我想使用版本回退操作，我想把当前的版本回退到上一个版本，要使用什么命令呢？可以使用如下2种命令，第一种是：git reset --hard HEAD^ 那么如果要回退到上上个版本只需把HEAD^ 改成 HEAD^^ 以此类推。那如果要回退到前100个版本的话，使用上面的方法肯定不方便，我们可以使用下面的简便命令操作：git reset --hard HEAD~100 即可。未回退之前的readme.txt内容如下： 如果想回退到上一个版本的命令如下操作： 再来查看下 readme.txt内容如下：通过命令cat readme.txt查看 可以看到，内容已经回退到上一个版本了。我们可以继续使用git log 来查看下历史记录信息，如下： 我们看到 增加333333 内容我们没有看到了，但是现在我想回退到最新的版本，如：有333333的内容要如何恢复呢？我们可以通过版本号回退，使用命令方法如下： git reset –hard 版本号 ，但是现在的问题假如我已经关掉过一次命令行或者333内容的版本号我并不知道呢？要如何知道增加3333内容的版本号呢？可以通过如下命令即可获取到版本号：git reflog 演示如下： 通过上面的显示我们可以知道，增加内容3333的版本号是 6fcfc89.我们现在可以命令 git reset –hard 6fcfc89来恢复了。演示如下： 可以看到 目前已经是最新的版本了。 三：理解工作区与暂存区的区别？ **工作区：**就是你在电脑上看到的目录，比如目录下testgit里的文件(.git隐藏目录版本库除外)。或者以后需要再新建的目录文件等等都属于工作区范畴。 版本库**(Repository)**：工作区有一个隐藏目录.git,这个不属于工作区，这是版本库。其中版本库里面存了很多东西，其中最重要的就是stage(暂存区)，还有Git为我们自动创建了第一个分支master,以及指向master的一个指针HEAD。 我们前面说过使用Git提交文件到版本库有两步： 第一步：是使用 git add 把文件添加进去，实际上就是把文件添加到暂存区。 第二步：使用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支上。 我们继续使用demo来演示下： 我们在readme.txt再添加一行内容为4444444，接着在目录下新建一个文件为test.txt 内容为test，我们先用命令 git status来查看下状态，如下： 现在我们先使用git add 命令把2个文件都添加到暂存区中，再使用git status来查看下状态，如下： 接着我们可以使用git commit一次性提交到分支上，如下： 四：Git撤销修改和删除文件操作。 一：撤销修改： 比如我现在在readme.txt文件里面增加一行 内容为555555555555，我们先通过命令查看如下： 在我未提交之前，我发现添加5555555555555内容有误，所以我得马上恢复以前的版本，现在我可以有如下几种方法可以做修改： 第一：如果我知道要删掉那些内容的话，直接手动更改去掉那些需要的文件，然后add添加到暂存区，最后commit掉。 第二：我可以按以前的方法直接恢复到上一个版本。使用 git reset –hard HEAD^ 但是现在我不想使用上面的2种方法，我想直接想使用撤销命令该如何操作呢？首先在做撤销之前，我们可以先用 git status 查看下当前的状态。如下所示： 可以发现，Git会告诉你，git checkout – file 可以丢弃工作区的修改，如下命令： git checkout – readme.txt,如下所示： 命令 git checkout –readme.txt 意思就是，把readme.txt文件在工作区做的修改全部撤销，这里有2种情况，如下： readme.txt自动修改后，还没有放到暂存区，使用 撤销修改就回到和版本库一模一样的状态。 另外一种是readme.txt已经放入暂存区了，接着又作了修改，撤销修改就回到添加暂存区后的状态。 对于第二种情况，我想我们继续做demo来看下，假如现在我对readme.txt添加一行 内容为6666666666666，我git add 增加到暂存区后，接着添加内容7777777，我想通过撤销命令让其回到暂存区后的状态。如下所示： 注意：命令git checkout – readme.txt 中的 – 很重要，如果没有 – 的话，那么命令变成创建分支了。 二：删除文件。 假如我现在版本库testgit目录添加一个文件b.txt,然后提交。如下： 如上：一般情况下，可以直接在文件目录中把文件删了，或者使用如上rm命令：rm b.txt ，如果我想彻底从版本库中删掉了此文件的话，可以再执行commit命令 提交掉，现在目录是这样的， 只要没有commit之前，如果我想在版本库中恢复此文件如何操作呢？ 可以使用如下命令 git checkout – b.txt，如下所示： 再来看看我们testgit目录，添加了3个文件了。如下所示： 五：远程仓库。 在了解之前，先注册github账号，由于你的本地Git仓库和github仓库之间的传输是通过SSH加密的，所以需要一点设置： 第一步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果有的话，直接跳过此如下命令，如果没有的话，打开命令行，输入如下命令： ssh-keygen -t rsa –C “youremail@example.com”, 由于我本地此前运行过一次，所以本地有，如下所示： id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。 第二步：登录github,打开” settings”中的SSH Keys页面，然后点击“Add SSH Key”,填上任意title，在Key文本框里黏贴id_rsa.pub文件的内容。 点击 Add Key，你就应该可以看到已经添加的key。 如何添加远程库？ 现在的情景是：我们已经在本地创建了一个Git仓库后，又想在github创建一个Git仓库，并且希望这两个仓库进行远程同步，这样github的仓库可以作为备份，又可以其他人通过该仓库来协作。 首先，登录github上，然后在右上角找到“create a new repo”创建一个新的仓库。如下： 在Repository name填入testgit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库： 目前，在GitHub上的这个`testgit`仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。 现在，我们根据GitHub的提示，在本地的testgit仓库下运行命令： git remote add origin https://github.com/tugenhua0707/testgit.git 所有的如下： 把本地库的内容推送到远程，使用 git push命令，实际上是把当前分支master推送到远程。 由于远程库是空的，我们第一次推送master分支时，加上了 –u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。推送成功后，可以立刻在github页面中看到远程库的内容已经和本地一模一样了，上面的要输入github的用户名和密码如下所示： 从现在起，只要本地作了提交，就可以通过如下命令： git push origin master 把本地master分支的最新修改推送到github上了，现在你就拥有了真正的分布式版本库了。 2. 如何从远程库克隆？ 上面我们了解了先有本地库，后有远程库时候，如何关联远程库。 现在我们想，假如远程库有新的内容了，我想克隆到本地来 如何克隆呢？ 首先，登录github，创建一个新的仓库，名字叫testgit2.如下： 如下，我们看到： 现在，远程库已经准备好了，下一步是使用命令git clone克隆一个本地库了。如下所示： 接着在我本地目录下 生成testgit2目录了，如下所示： 六：创建与合并分支。 在 版本回填退里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。 首先，我们来创建dev分支，然后切换到dev分支上。如下操作： git checkout 命令加上 –b参数表示创建并切换，相当于如下2条命令 git branch dev git checkout dev git branch查看分支，会列出所有的分支，当前分支前面会添加一个星号。然后我们在dev分支上继续做demo，比如我们现在在readme.txt再增加一行 7777777777777 首先我们先来查看下readme.txt内容，接着添加内容77777777，如下： 现在dev分支工作已完成，现在我们切换到主分支master上，继续查看readme.txt内容如下： 现在我们可以把dev分支上的内容合并到分支master上了，可以在master分支上，使用如下命令 git merge dev 如下所示： git merge命令用于合并指定分支到当前分支上，合并后，再查看readme.txt内容，可以看到，和dev分支最新提交的是完全一样的。 注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。 合并完成后，我们可以接着删除dev分支了，操作如下： 总结创建与合并分支命令如下： 查看分支：git branch 创建分支：git branch name 切换分支：git checkout name 创建+切换分支：git checkout –b name 合并某分支到当前分支：git merge name 删除分支：git branch –d name 如何解决冲突？ 下面我们还是一步一步来，先新建一个新分支，比如名字叫fenzhi1，在readme.txt添加一行内容8888888，然后提交，如下所示： 同样，我们现在切换到master分支上来，也在最后一行添加内容，内容为99999999，如下所示： 现在我们需要在master分支上来合并fenzhi1，如下操作： Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，其中&lt;&lt;&lt;HEAD是指主分支修改的内容，&gt;&gt;&gt;&gt;&gt;fenzhi1 是指fenzhi1上修改的内容，我们可以修改下如下后保存： 如果我想查看分支合并的情况的话，需要使用命令 git log.命令行演示如下： 3.分支管理策略。 通常合并分支时，git一般使用”Fast forward”模式，在这种模式下，删除分支后，会丢掉分支信息，现在我们来使用带参数 –no-ff来禁用”Fast forward”模式。首先我们来做demo演示下： 创建一个dev分支。 修改readme.txt内容。 添加到暂存区。 切换回主分支(master)。 合并dev分支，使用命令 git merge –no-ff -m “注释” dev 查看历史记录 截图如下： 分支策略：首先master主分支应该是非常稳定的，也就是用来发布新版本，一般情况下不允许在上面干活，干活一般情况下在新建的dev分支上干活，干完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。 七：bug分支： 在开发中，会经常碰到bug问题，那么有了bug就需要修复，在Git中，分支是很强大的，每个bug都可以通过一个临时分支来修复，修复完成后，合并分支，然后将临时的分支删除掉。 比如我在开发中接到一个404 bug时候，我们可以创建一个404分支来修复它，但是，当前的dev分支上的工作还没有提交。比如如下： 并不是我不想提交，而是工作进行到一半时候，我们还无法提交，比如我这个分支bug要2天完成，但是我issue-404 bug需要5个小时内完成。怎么办呢？还好，Git还提供了一个stash功能，可以把当前工作现场 ”隐藏起来”，等以后恢复现场后继续工作。如下： 所以现在我可以通过创建issue-404分支来修复bug了。 首先我们要确定在那个分支上修复bug，比如我现在是在主分支master上来修复的，现在我要在master分支上创建一个临时分支，演示如下： 修复完成后，切换到master分支上，并完成合并，最后删除issue-404分支。演示如下： 现在，我们回到dev分支上干活了。 工作区是干净的，那么我们工作现场去哪里呢？我们可以使用命令 git stash list来查看下。如下： 工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，可以使用如下2个方法： git stash apply恢复，恢复后，stash内容并不删除，你需要使用命令git stash drop来删除。 另一种方式是使用git stash pop,恢复的同时把stash内容也删除了。 演示如下 八：多人协作。 当你从远程库克隆时候，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且远程库的默认名称是origin。 要查看远程库的信息 使用 git remote 要查看远程库的详细信息 使用 git remote –v 如下演示： 一：推送分支： 推送分支就是把该分支上所有本地提交到远程库中，推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上： 使用命令 git push origin master 比如我现在的github上的readme.txt代码如下： 本地的readme.txt代码如下： 现在我想把本地更新的readme.txt代码推送到远程库中，使用命令如下： 我们可以看到如上，推送成功，我们可以继续来截图github上的readme.txt内容 如下： 可以看到 推送成功了，如果我们现在要推送到其他分支，比如dev分支上，我们还是那个命令 git push origin dev 那么一般情况下，那些分支要推送呢？ master分支是主分支，因此要时刻与远程同步。 一些修复bug分支不需要推送到远程去，可以先合并到主分支上，然后把主分支master推送到远程去。 二：抓取分支： 多人协作时，大家都会往master分支上推送各自的修改。现在我们可以模拟另外一个同事，可以在另一台电脑上（注意要把SSH key添加到github上）或者同一台电脑上另外一个目录克隆，新建一个目录名字叫testgit2 但是我首先要把dev分支也要推送到远程去，如下 接着进入testgit2目录，进行克隆远程的库到本地来，如下： 现在目录下生成有如下所示： 现在我们的小伙伴要在dev分支上做开发，就必须把远程的origin的dev分支到本地来，于是可以使用命令创建本地dev分支：git checkout –b dev origin/dev 现在小伙伴们就可以在dev分支上做开发了，开发完成后把dev分支推送到远程库时。 如下： 小伙伴们已经向origin/dev分支上推送了提交，而我在我的目录文件下也对同样的文件同个地方作了修改，也试图推送到远程库时，如下： 由上面可知：推送失败，因为我的小伙伴最新提交的和我试图推送的有冲突，解决的办法也很简单，上面已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后在本地合并，解决冲突，再推送。 git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接：如下： 这回git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的 解决冲突完全一样。解决后，提交，再push： 我们可以先来看看readme.txt内容了。 现在手动已经解决完了，我接在需要再提交，再push到远程库里面去。如下所示： 因此：多人协作工作模式一般是这样的： 首先，可以试图用git push origin branch-name推送自己的修改. 如果推送失败，则因为远程分支比你的本地更新早，需要先用git pull试图合并。 如果合并有冲突，则需要解决冲突，并在本地提交。再用git push origin branch-name推送。 Git**基本常用命令如下：** mkdir： XX (创建一个空目录 XX指目录名) pwd： 显示当前目录的路径。 git init 把当前的目录变成可以管理的git仓库，生成隐藏.git文件。 git add XX 把xx文件添加到暂存区去。 git commit –m “XX” 提交文件 –m 后面的是注释。 git status 查看仓库状态 git diff XX 查看XX文件修改了那些内容 git log 查看历史记录 git reset –hard HEAD^ 或者 git reset –hard HEAD~ 回退到上一个版本 (如果想回退到100个版本，使用git reset –hard HEAD~100 ) cat XX 查看XX文件内容 git reflog 查看历史记录的版本号id git checkout – XX 把XX文件在工作区的修改全部撤销。 git rm XX 删除XX文件 git remote add origin https://github.com/tugenhua0707/testgit 关联一个远程库 git push –u(第一次要用-u 以后不需要) origin master 把当前master分支推送到远程库 git clone https://github.com/tugenhua0707/testgit 从远程库中克隆 git checkout –b dev 创建dev分支 并切换到dev分支上 git branch 查看当前所有的分支 git checkout master 切换回master分支 git merge dev 在当前的分支上合并dev分支 git branch –d dev 删除dev分支 git branch name 创建分支 git stash 把当前的工作隐藏起来 等以后恢复现场后继续工作 git stash list 查看所有被隐藏的文件列表 git stash apply 恢复被隐藏的文件，但是内容不删除 git stash drop 删除文件 git stash pop 恢复文件的同时 也删除文件 git remote 查看远程库的信息 git remote –v 查看远程库的详细信息 git push origin master Git会把master分支推送到远程库对应的远程分支上]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[如何用命令将本地项目上传到git]]></title>
    <url>%2F2017%2F02%2F19%2Fe5-a6-82-e4-bd-95-e7-94-a8-e5-91-bd-e4-bb-a4-e5-b0-86-e6-9c-ac-e5-9c-b0-e9-a1-b9-e7-9b-ae-e4-b8-8a-e4-bc-a0-e5-88-b0git%2F</url>
    <content type="text"><![CDATA[http://www.cnblogs.com/eedc/p/6168430.html 1、（先进入项目文件夹）通过命令 git init 把这个目录变成git可以管理的仓库 git init2、把文件添加到版本库中，使用命令 git add .添加到暂存区里面去，不要忘记后面的小数点“.”，意为添加文件夹下的所有文件 git add .3、用命令 git commit告诉Git，把文件提交到仓库。引号内为提交说明 git commit -m ‘first commit’4、关联到远程库 git remote add origin 你的远程库地址如： git remote add origin https://github.com/cade8800/ionic-demo.git5、获取远程库与本地同步合并（如果远程库不为空必须做这一步，否则后面的提交会失败） git pull –rebase origin master6、把本地库的内容推送到远程，使用 git push命令，实际上是把当前分支master推送到远程。执行此命令后会要求输入用户名、密码，验证通过后即开始上传。 git push -u origin master*、状态查询命令 git status备：详细请参考 http://www.cnblogs.com/tugenhua0707/p/4050072.html]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【VSCode】Windows下VSCode编译调试c/c++]]></title>
    <url>%2F2017%2F02%2F16%2Fe3-80-90vscode-e3-80-91windows-e4-b8-8bvscode-e7-bc-96-e8-af-91-e8-b0-83-e8-af-95cc%2F</url>
    <content type="text"><![CDATA[http://blog.csdn.net/c_duoduo/article/details/51615381 懒得自己配置或自己配置出现不明问题的朋友可以点这里：【VSCode】Windows下VSCode便携式c/c++环境http://blog.csdn.net/c_duoduo/article/details/52083494下载解压即可食用。 ————————– 以下是原文 ————————- 这篇文章为blackkitty记录在windows下使用vscode编译调试c/c++的详细过程 首先看效果设置断点，变量监视，调用堆栈的查看： 条件断点的使用： 下面是配置过程： 总体流程： 下载安装vscode 安装cpptools插件 安装编译、调试环境 修改vscode调试配置文件 完了下载安装vscodehttps://code.visualstudio.com/Download点击下载自己喜欢的相应版本，绿色版解压即可食用 安装cpptools插件打开vscode，按ctrl+e打开快速命令框，输入以下命令后等待 ext install cpptoolsvscode在短暂的联网查找后会列出插件列表，如图：点击箭头所指处的按钮安装插件，安装过程可能会有些慢耐心等待安装完成后vscode会提示你重启vscode，此时重启即可 安装编译、调试环境 目前windows下调试仅支持 Cygwin 和 MinGW。这里使用的是MinGW.下面是MinGW的安装配置过程：http://mingw.org/进入官网点击右侧 Download Installer下载安装器打开安装器点击install准备安装： 选择一个安装目录，默认为C:\MinGW这里选择的是A:\MinGW点击Continue开始安装，安装过程需联网，若安装时提示error则需翻墙安装安装过程很快，结束后Continue按钮恢复为可用状态，点击完成安装。 打开MinGW安装管理器进行进一步配置 注意这里gdb必选，否则无法调试选中几个需要的项右键Make for Installation进行标记，其中gcc和g++为c和c++编译器选择完全部想要安装的项后点击左上角Installation菜单下的Apply Changes应用修改，过程需联网，中间出现error可先继续，若最后失败则需翻墙更新，建议翻墙 然后配置系统环境变量path，这一步为必须 在 我的电脑 上右键 属性：然后按照下面步骤做即可，注意最后新建的项要与之前MinGW安装位置相对应 修改vscode调试配置文件再次打开vscode，注意配置系统环境变量path后重启一下vscode注意vscode调试需要在打开的文件夹中进行 打开文件夹后，新建test.cpp进行输入代码测试： 如图示进入调试界面选择C++： 然后会在工作目录下的生成一个launch.json的启动配置文件: 使用下面代码替换该文件： { &lt;span class=&quot;hljs-string&quot;&gt;&quot;version&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;0.2.0&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;configurations&quot;&lt;/span&gt;: [ { &lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;C++ Launch (GDB)&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-comment&quot;&gt;// 配置名称，将会在启动配置的下拉菜单中显示&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;type&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;cppdbg&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-comment&quot;&gt;// 配置类型，这里只能为cppdbg&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;request&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;launch&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-comment&quot;&gt;// 请求配置类型，可以为launch（启动）或attach（附加）&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;launchOptionType&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;Local&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-comment&quot;&gt;// 调试器启动类型，这里只能为Local&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;targetArchitecture&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;x86&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-comment&quot;&gt;// 生成目标架构，一般为x86或x64，可以为x86, arm, arm64, mips, x64, amd64, x86_64&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;program&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;${file}.exe&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-comment&quot;&gt;// 将要进行调试的程序的路径&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;miDebuggerPath&quot;&lt;/span&gt;:&lt;span class=&quot;hljs-string&quot;&gt;&quot;a:\\MinGW\\bin\\gdb.exe&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-comment&quot;&gt;// miDebugger的路径，注意这里要与MinGw的路径对应&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;args&quot;&lt;/span&gt;: [&lt;span class=&quot;hljs-string&quot;&gt;&quot;blackkitty&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;1221&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;# #&quot;&lt;/span&gt;], &lt;span class=&quot;hljs-comment&quot;&gt;// 程序调试时传递给程序的命令行参数，一般设为空即可&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;stopAtEntry&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-keyword&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;hljs-comment&quot;&gt;// 设为true时程序将暂停在程序入口处，一般设置为false&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;cwd&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;${workspaceRoot}&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-comment&quot;&gt;// 调试程序时的工作目录，一般为${workspaceRoot}即代码所在目录&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;externalConsole&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;, &lt;span class=&quot;hljs-comment&quot;&gt;// 调试时是否显示控制台窗口，一般设置为true显示控制台&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;preLaunchTask&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;g++&quot;&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot;&gt;// 调试会话开始前执行的任务，一般为编译程序，c++为g++, c为gcc&lt;/span&gt; } ] }`&lt;/pre&gt; **注意miDebuggerPath要与MinGw的路径对应** 替换后保存，然后切换至test.cpp，按F5进行调试，此时会弹出一个信息框要求你配置任务运行程序，点击它~ ![这里写图片描述](http://img.blog.csdn.net/20160608224046717) 在这里随便选一个： ![这里写图片描述](http://img.blog.csdn.net/20160608224840837) 然后用下面代码替换： &lt;pre class=&quot;prettyprint&quot; name=&quot;code&quot;&gt;`{ &lt;span class=&quot;hljs-string&quot;&gt;&quot;version&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;0.1.0&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;command&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;g++&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;args&quot;&lt;/span&gt;: [&lt;span class=&quot;hljs-string&quot;&gt;&quot;-g&quot;&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;${file}&lt;/span&gt;&quot;&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;&quot;-o&quot;&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;${file}&lt;/span&gt;.exe&quot;&lt;/span&gt;], // 编译命令参数 &lt;span class=&quot;hljs-string&quot;&gt;&quot;problemMatcher&quot;&lt;/span&gt;: { &lt;span class=&quot;hljs-string&quot;&gt;&quot;owner&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;cpp&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;fileLocation&quot;&lt;/span&gt;: [&lt;span class=&quot;hljs-string&quot;&gt;&quot;relative&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;${workspaceRoot}&lt;/span&gt;&quot;&lt;/span&gt;], &lt;span class=&quot;hljs-string&quot;&gt;&quot;pattern&quot;&lt;/span&gt;: { &lt;span class=&quot;hljs-string&quot;&gt;&quot;regexp&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;^(.*):(\\d+):(\\d+):\\s+(warning|error):\\s+(.*)$&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;file&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;line&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;column&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;severity&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;message&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt; } } } 保存一下，然后切换至test.cpp，再次按F5启动调试~ 完了！]]></content>
      <categories>
        <category>CPlus</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言文件操作详解]]></title>
    <url>%2F2017%2F02%2F16%2Fc-e8-af-ad-e8-a8-80-e6-96-87-e4-bb-b6-e6-93-8d-e4-bd-9c-e8-af-a6-e8-a7-a3%2F</url>
    <content type="text"><![CDATA[http://www.cnblogs.com/likebeta/archive/2012/06/16/2551780.html C语言中没有输入输出语句，所有的输入输出功能都用 ANSI C提供的一组标准库函数来实现。文件操作标准库函数有： 文件的打开操作 fopen 打开一个文件 文件的关闭操作 fclose 关闭一个文件 文件的读写操作 fgetc 从文件中读取一个字符fputc 写一个字符到文件中去fgets 从文件中读取一个字符串fputs 写一个字符串到文件中去fprintf 往文件中写格式化数据fscanf 格式化读取文件中数据fread 以二进制形式读取文件中的数据fwrite 以二进制形式写数据到文件中去getw 以二进制形式读取一个整数putw 以二进制形式存贮一个整数 文件状态检查函数 feof 文件结束ferror 文件读/写出错clearerr 清除文件错误标志ftell 了解文件指针的当前位置 文件定位函数 rewind 反绕fseek 随机定位 # 文件的打开1．函数原型 FILE fopen(char pname,char mode)2．功能说明按照mode 规定的方式，打开由pname指定的文件。若找不到由pname指定的相应文件，就按以下方式之一处理：（1） 此时如mode 规定按写方式打开文件，就按由pname指定的名字建立一个新文件；（2） 此时如mode 规定按读方式打开文件，就会产生一个错误。打开文件的作用是：（1）分配给打开文件一个FILE 类型的文件结构体变量，并将有关信息填入文件结构体变量；（2）开辟一个缓冲区；（3）调用操作系统提供的打开文件或建立新文件功能，打开或建立指定文件；FILE ：指出fopen是一个返回文件类型的指针函数；3．参数说明pname：是一个字符指针，它将指向要打开或建立的文件的文件名字符串。mode：是一个指向文件处理方式字符串的字符指针。所有可能的文件处理方式见表8.14．返回值正常返回：被打开文件的文件指针。异常返回：NULL，表示打开操作不成功。例如：12345678//定义一个名叫fp文件指针FILE *fp；//判断按读方式打开一个名叫test的文件是否失败if((fp=fopen（"test"，"r"）) == NULL)//打开操作不成功&#123; printf("The file can not be opened.\n")； exit(1);//结束程序的执行&#125;要说明的是：C语言将计算机的输入输出设备都看作是文件。例如，键盘文件、屏幕文件等。ANSI C标准规定，在执行程序时系统先自动打开键盘、屏幕、错误三个文件。这三个文件的文件指针分别是：标准输入stdin、标准输出stdout和标准出错 stderr。* 文件的关闭1． 函数原型int fclose(FILE fp)；2． 功能说明关闭由fp指出的文件。此时调用操作系统提供的文件关闭功能，关闭由fp-&gt;fd指出的文件；释放由fp指出的文件类型结构体变量；返回操作结果，即0或EOF。3． 参数说明fp：一个已打开文件的文件指针。4． 返回值正常返回：0。异常返回：EOF，表示文件在关闭时发生错误。例如：int n=fclose(fp);**文件的读写操作A. 从文件中读取一个字符1． 函数原型int fgetc(FILE fp)；2． 功能说明从fp所指文件中读取一个字符。3． 参数说明fp：这是个文件指针，它指出要从中读取字符的文件。4． 返回值正常返回： 返回读取字符的代码。非正常返回：返回EOF。例如，要从”写打开”文件中读取一个字符时，会发生错误而返回一个EOF。5． 实例【例8.1】显示指定文件的内容。1234567891011121314151617181920212223242526272829//程序名为：display.c//执行时可用：display filename1 形式的命令行运行。显示文件filename1中的内容。例如，执行命令行display display.c将在屏幕上显示display的原代码。//File display program.#include &amp;lt;stdio.h&amp;gt;void main(int argc,char *argv[]) //命令行参数&#123; int ch;//定义文件类型指针 FILE *fp;//判断命令行是否正确 if(argc!=2) &#123; printf("Error format,Usage: display filename1\n"); return; //键入了错误的命令行，结束程序的执行 &#125; //按读方式打开由argv[1]指出的文件 if((fp=fopen(argv[1],"r"))==NULL) &#123; printf("The file &amp;lt;%s&amp;gt; can not be opened.\n",argv[1]);//打开操作不成功 return;//结束程序的执行 &#125; //成功打开了argv[1]所指文件 ch=fgetc(fp); //从fp所指文件的当前指针位置读取一个字符 while(ch!=EOF) //判断刚读取的字符是否是文件结束符 &#123; putchar(ch); //若不是结束符，将它输出到屏幕上显示 ch=fgetc(fp); //继续从fp所指文件中读取下一个字符 &#125; //完成将fp所指文件的内容输出到屏幕上显示 fclose(fp); //关闭fp所指文件&#125;B. 写一个字符到文件中去1． 函数原型int fputc(int ch,FILE fp)2． 功能说明把ch中的字符写入由fp指出的文件中去。3． 参数说明ch：是一个整型变量，内存要写到文件中的字符（C语言中整型量和字符量可以通用）。fp：这是个文件指针，指出要在其中写入字符的文件。4． 返回值正常返回： 要写入字符的代码。非正常返回：返回EOF。例如，要往”读打开”文件中写一个字符时，会发生错误而返回一个EOF。5． 实例【例8.2】将一个文件的内容复制到另一个文件中去。123456789101112131415161718192021222324252627282930313233343536//程序名为：copyfile.c//执行时可用：copyfile filename1 filename2形式的命令行运行，将文件filename1中的内容复制到文件filename2中去。//file copy program.#include &amp;lt;stdio.h&amp;gt;void main(int argc,char *argv[]) //命令行参数&#123; int ch; FILE *in,*out; //定义in和out两个文件类型指针 if(argc!=3) //判断命令行是否正确 &#123; printf("Error in format,Usage: copyfile filename1 filename2\n"); return; //命令行错，结束程序的执行 &#125; //按读方式打开由argv[1]指出的文件 if((in=fopen(argv[1],"r"))==NULL) &#123; printf("The file &amp;lt;%s&amp;gt; can not be opened.\n",argv[1]); return; //打开失败，结束程序的执行 &#125; //成功打开了argv[1]所指文件，再 //按写方式打开由argv[2]指出的文件 if((out=fopen(argv[2],"w"))==NULL) &#123; printf("The file %s can not be opened.\n",argv[2]); return; //打开失败，结束程序的执行 &#125; //成功打开了argv[2]所指文件 ch=fgetc(in); //从in所指文件的当前指针位置读取一个字符 while(ch!=EOF) //判断刚读取的字符是否是文件结束符 &#123; fputc(ch,out); //若不是结束符，将它写入out所指文件 ch=fgetc(in); //继续从in所指文件中读取下一个字符 &#125; //完成将in所指文件的内容写入（复制）到out所指文件中 fclose(in); //关闭in所指文件 fclose(out); //关闭out所指文件&#125;【例8.3】按十进制和字符显示文件代码，若遇不可示字符就用井号”#”字符代替之。12345678910111213141516171819202122232425262728293031323334353637383940414243//程序名为：dumpf.c//执行时可用：dumpf filename1 形式的命令行运行。// File dump program.#include &amp;lt;stdio.h&amp;gt;void main(int argc,char *argv[])&#123; char str[9]; int ch,count,i; FILE *fp; if(argc!=2) &#123; printf("Error format,Usage: dumpf filename\n"); return; &#125; if((fp=fopen(argv[1],"r"))==NULL) &#123; printf("The file %s can not be opened.\n",argv[1]); return; &#125; count=0; do&#123; i=0; //按八进制输出第一列，作为一行八个字节的首地址 printf("%06o: ",count*8); do&#123; // 从打开的文件中读取一个字符 ch=fgetc(fp); // 按十进制方式输出这个字符的ASCII码 printf("%4d",ch); // 如果是不可示字符就用"#"字符代替 if(ch&amp;lt;' '||ch&amp;gt;'~') str[i]='#'; // 如果是可示字符，就将它存入数组str以便形成字符串 else str[i]=ch; // 保证每一行输出八个字符 if(++i==8) break; &#125;while(ch!=EOF); // 遇到文件尾标志，结束读文件操作 str[i]='\0'; // 在数组str加字符串结束标志 for(;i&amp;lt;8;i++) printf(" "); // 一行不足八个字符用空格填充 printf(" %s\n",str); // 输出字符串 count++; // 准备输出下一行 &#125;while(ch!=EOF); // 直到文件结束 fclose(fp); // 关闭fp所指文件&#125;C. 从文件中读取一个字符串1． 函数原型char fgets(char str,int n,FILE fp)2． 功能说明从由fp指出的文件中读取n-1个字符，并把它们存放到由str指出的字符数组中去，最后加上一个字符串结束符’\0’。3． 参数说明str：接收字符串的内存地址，可以是数组名，也可以是指针。n： 指出要读取字符的个数。fp：这是个文件指针，指出要从中读取字符的文件。4． 返回值正常返回：返回字符串的内存首地址，即str的值。非正常返回：返回一个NULL值，此时应当用feof()或ferror()函数来判别是读取到了文件尾，还是发生了错误。例如，要从”写打开”文件中读取字符串，将发生错误而返回一个NULL值。D. 写一个字符串到文件中去1． 函数原型int fputs(char str,FILE fp)2． 功能说明把由str指出的字符串写入到fp所指的文件中去。3． 参数说明str：指出要写到文件中去的字符串。fp：这是个文件指针，指出字符串要写入其中的文件。4． 返回值正常返回： 写入文件的字符个数，即字符串的长度。非正常返回：返回一个NULL值，此时应当用feof()或ferror()函数来判别是读取到了文件尾，还是发生了错误。例如，要往一个”读打开” 文件中写字符串时，会发生错误而返回一个NULL值。5．实例【例8.4】以下程序将一个文件的内容附加到另一个文件中去。1234567891011121314151617181920212223242526272829303132333435363738394041//程序名：linkfile.c//执行时可用：linkfile filename1 filename2形式的命令行运行，将文件filename2的内容附加在文件filename1之后。// file linked program.#include &amp;lt;stdio.h&amp;gt;#define SIZE 512void main(int argc,char *argv[])&#123; char buffer[SIZE]; FILE *fp1,*fp2; if(argc!=3) &#123; printf("Usage: linkfile filename1 filename2\n"); return; &#125; // 按追加方式打开argv[1] 所指文件 if((fp1=fopen(argv[1],"a"))==NULL) &#123; printf("The file %s can not be opened.\n",argv[1]); return; &#125; if((fp2=fopen(argv[2],"r"))==NULL) &#123; printf("The file %s can not be opened.\n",argv[2]); return; &#125; // 读入一行立即写出，直到文件结束 while(fgets(buffer,SIZE,fp1)!=NULL) printf("%s\n",buffer); while(fgets(buffer,SIZE,fp2)!=NULL) fputs(buffer,fp1); fclose(fp1); fclose(fp2); if((fp1=fopen(argv[1],"r"))==NULL) &#123; printf("The file %s can not be opened.\n",argv[1]); return; &#125; while(fgets(buffer,SIZE,fp1)!=NULL) printf("%s\n",buffer); fclose(fp1);&#125;E. 往文件中写格式化数据1．函数原型int fprintf(FILE fp,char format,arg_list)2．功能说明将变量表列（arg_list）中的数据，按照format指出的格式，写入由fp指定的文件。fprintf()函数与printf()函数的功能相同，只是printf()函数是将数据写入屏幕文件（stdout）。3．参数说明fp：这是个文件指针，指出要将数据写入的文件。format：这是个指向字符串的字符指针，字符串中含有要写出数据的格式，所以该字符串成为格式串。格式串描述的规则与printf()函数中的格式串相同。arg_list：是要写入文件的变量表列，各变量之间用逗号分隔。4．返回值无。5． 实例【8.5】下列程序的执行文件为display.exe，执行时键入命令行：display [-i][-s] filename下面的表格列出了命令行参数的含义及其功能：12345678910111213141516171819202122232425262728//存储文件名：save.txt//程序代码如下：// file display program.#include &amp;lt;stdio.h&amp;gt;void main()&#123; char name[10]; int nAge,nClass; long number; FILE *fp; if((fp=fopen("student.txt","w"))==NULL) &#123; printf("The file %s can not be opened.\n","student.txt"); return; &#125; fscanf(stdin,"%s %d %d %ld",name,&amp;amp;nClass,&amp;amp;nAge,&amp;amp;number); fprintf(fp,"%s %5d %4d %8ld",name,nClass,nAge,number); fclose(fp); if((fp=fopen("student.txt","r"))==NULL) &#123; printf("The file %s can not be opened.\n","student.txt"); return; &#125; fscanf(fp,"%s %d %d %ld",name,&amp;amp;nClass,&amp;amp;nAge,&amp;amp;number); printf("name nClass nAge number\n"); fprintf(stdout,"%-10s%-8d%-6d%-8ld\n",name,nClass,nAge,number); fclose(fp);&#125;G. 以二进制形式读取文件中的数据1． 函数原型int fread(void buffer,unsigned sife,unsigned count,FILE fp)2． 功能说明从由fp指定的文件中，按二进制形式将sifecount个数据读到由buffer指出的数据区中。3． 参数说明buffer：这是一个void型指针，指出要将读入数据存放在其中的存储区首地址。sife：指出一个数据块的字节数，即一个数据块的大小尺寸。count：指出一次读入多少个数据块（sife）。fp：这是个文件指针，指出要从其中读出数据的文件。4．返回值正常返回：实际读取数据块的个数，即count。异常返回：如果文件中剩下的数据块个数少于参数中count指出的个数，或者发生了错误，返回0值。此时可以用feof()和ferror()来判定到底出现了什么情况。H. 以二进制形式写数据到文件中去1． 函数原型int fwrite(void buffer,unsigned sife,unsigned count,FILE fp)2． 功能说明按二进制形式，将由buffer指定的数据缓冲区内的sifecount个数据写入由fp指定的文件中去。3． 参数说明buffer：这是一个void型指针，指出要将其中数据输出到文件的缓冲区首地址。sife：指出一个数据块的字节数，即一个数据块的大小尺寸。count：一次输出多少个数据块（sife）。fp：这是个文件指针，指出要从其中读出数据的文件。4．返回值正常返回：实际输出数据块的个数，即count。异常返回：返回0值，表示输出结束或发生了错误。5．实例【例8.7】123456789101112131415161718192021222324252627#include &amp;lt;stdio.h&amp;gt;#define SIZE 4struct worker&#123; int number; char name[20]; int age;&#125;;void main()&#123; struct worker wk; int n; FILE *in,*out; if((in=fopen("file1.txt","rb"))==NULL) &#123; printf("The file %s can not be opened.\n","file1.txt"); return; &#125; if((out=fopen("file2.txt","wb"))==NULL) &#123; printf("The file %s can not be opened.\n","file2.txt"); return; &#125; while(fread(&amp;amp;wk,sizeof(struct worker),1,in)==1) fwrite(&amp;amp;wk,sizeof(struct worker),1,out); fclose(in); fclose(out);&#125;I. 以二进制形式读取一个整数1． 函数原型int getw(FILE fp)2． 功能说明从由fp指定的文件中，以二进制形式读取一个整数。3． 参数说明fp：是文件指针。4． 返回值正常返回：所读取整数的值。异常返回：返回EOF，即-1。由于读取的整数值有可能是-1，所以必须用feof()或ferror()来判断是到了文件结束，还是出现了一个出错。5． 实例【例8.8】12345678910111213141516171819#include &amp;lt;stdio.h&amp;gt;void main(int argc,char *argv[])&#123; int i,sum=0; FILE *fp; if(argc!=2) &#123; printf("Command error,Usage: readfile filename\n"); exit(1); &#125; if(!(fp=fopen(argv[1],"rb"))) &#123; printf("The file %s can not be opened.\n",argv[1]); exit(1); &#125; for(i=1;i&amp;lt;=10;i++) sum+=getw(fp); printf("The sum is %d\n",sum); fclose(fp);&#125;J. 以二进制形式存贮一个整数1．函数原型int putw(int n,FILE fp)2． 功能说明以二进制形式把由变量n指出的整数值存放到由fp指定的文件中。3． 参数说明n：要存入文件的整数。fp：是文件指针。4． 返回值正常返回：所输出的整数值。异常返回：返回EOF，即-1。由于输出的整数值有可能是-1，所以必须用feof()或ferror()来判断是到了文件结束，还是出现了一个出错。5． 实例【例8.9】12345678910111213141516171819#include &amp;lt;stdio.h&amp;gt;void main(int argc,char *argv[])&#123; int i; FILE *fp; if(argc!=2) &#123; printf("Command error,Usage: writefile filename\n"); return; &#125; if(!(fp=fopen(argv[1],"wb"))) &#123; printf("The file %s can not be opened.\n",argv[1]); return; &#125; for(i=1;i&amp;lt;=10;i++) printf("%d\n", putw(i,fp)); fclose(fp);&#125; 文件状态检查A. 文件结束（1） 函数原型int feof(FILE fp)（2） 功能说明该函数用来判断文件是否结束。（3） 参数说明fp：文件指针。（4） 返回值0：假值，表示文件未结束。1：真值，表示文件结束。（5） 实例【例8.10】1234567891011121314151617181920212223242526272829303132333435363738394041#include &amp;lt;stdio.h&amp;gt;void main(int argc,char *argv[])&#123; FILE *in,*out; char ch; if(argc!=3) &#123; printf("Usage: copyfile filename1 filename2\n"); return; &#125; if((in=fopen(argv[1],"rb"))==NULL) &#123; printf("The file %s can not be opened.\n",argv[1]); return; &#125; if((out=fopen(argv[2],"wb"))==NULL) &#123; printf("The file %s can not be opened.\n",argv[2]); return; &#125; while(!feof(in)) &#123; ch=fgetc(in); if(ferror(in)) &#123; printf("read error!\n"); clearerr(in); &#125; else &#123; fputc(ch,out); if(ferror(out)) &#123; printf("write error!\n"); clearerr(out); &#125; &#125; &#125; fclose(in); fclose(out);&#125;B. 文件读/写出错（1） 函数原型int ferror(FILE fp)（2） 功能说明检查由fp指定的文件在读写时是否出错。（3） 参数说明fp：文件指针。（4） 返回值0：假值，表示无错误。1：真值，表示出错。C. 清除文件错误标志（1） 函数原型void clearerr(FILE fp)（2） 功能说明清除由fp指定文件的错误标志。（3） 参数说明fp：文件指针。（4） 返回值无。（5） 实例【例8.12】1234567891011121314151617181920212223242526272829303132333435363738394041#include &amp;lt;stdio.h&amp;gt;void main(int argc,char *argv[])&#123; FILE *in,*out; char ch; if(argc!=3) &#123; printf("Usage: copyfile filename1 filename2\n"); return; &#125; if((in=fopen(argv[1],"rb"))==NULL) &#123; printf("The file %s can not be opened.\n",argv[1]); return; &#125; if((out=fopen(argv[2],"wb"))==NULL) &#123; printf("The file %s can not be opened.\n",argv[2]); return; &#125; while(!feof(in)) &#123; ch=fgetc(in); if(ferror(in)) &#123; printf("read error!\n"); clearerr(in); &#125; else &#123; fputc(ch,out); if(ferror(out)) &#123; printf("write error!\n"); clearerr(out); &#125; &#125; &#125; fclose(in); fclose(out);&#125;D. 了解文件指针的当前位置（1） 函数原型long ftell(FILE fp)（2） 功能说明取得由fp指定文件的当前读/写位置，该位置值用相对于文件开头的位移量来表示。（3） 参数说明fp：文件指针。（4） 返回值正常返回：位移量（这是个长整数）。异常返回：-1，表示出错。（5） 实例* 文件定位A. 反绕（1） 函数原型void rewind(FILE fp)（2） 功能说明使由文件指针fp指定的文件的位置指针重新指向文件的开头位置。（3） 参数说明fp：文件指针。（4） 返回值无。（5） 实例【例8.14】123456789101112#include &amp;lt;stdio.h&amp;gt;void main()&#123; FILE *in,*out; in=fopen("filename1","r"); out=fopen("filename2","w"); while(!feof(in)) fputc(fgetc(in),out); rewind(out); while(!feof(in)) putchar(fgetc(in)); fclose(in); fclose(out);&#125;B. 随机定位（1） 函数原型int fseek(FILE fp,long offset,int base)（2） 功能说明使文件指针fp移到基于base的相对位置offset处。（3）参数说明fp：文件指针。offset：相对base的字节位移量。这是个长整数，用以支持大于64KB的文件。base：文件位置指针移动的基准位置，是计算文件位置指针位移的基点。ANSI C定义了base的可能取值，以及这些取值的符号常量。（4）返回值正常返回：当前指针位置。异常返回：-1，表示定位操作出错。（5）实例【例8.15】1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;string.h&amp;gt;struct std_type&#123; int num; char name[20]; int age; char class;&#125;stud;int cstufile()&#123; int i; FILE *fp; if((fp=fopen("stufile","wb"))==NULL) &#123; printf("The file can't be opened for write.\n"); return 0; &#125; for(i=1;i&amp;lt;=100;i++) &#123; stud.num=i; strcpy(stud.name,"aaaa"); stud.age=17; stud.class='8'; fwrite(&amp;amp;stud,sizeof(struct std_type),1,fp); &#125; fclose(fp); return 1;&#125;void main()&#123; int n; FILE *fp; if(cstufile()==0) return; if((fp=fopen("stufile","rb"))==NULL) &#123; printf("The file can not be opened.\n"); return; &#125; for(n=0;n&amp;lt;100;n+=2) &#123; fseek(fp,n*sizeof(struct std_type),SEEK_SET); fread(&amp;amp;stud,sizeof(struct std_type),1,fp); printf("%10d%20s%10d%4c\n",stud.num,stud.name,stud.age,stud.class); &#125; fclose(fp);&#125;* 关于exit()函数1． 函数原型void exit(int status)2． 功能说明exit()函数使程序立即终止执行，同时将缓冲区中剩余的数据输出并关闭所有已经打开的文件。3． 参数说明status：为0值表示程序正常终止，为非0值表示一个定义错误。4． 返回值无。* 关于feof()函数*1． 函数原型int feof(FILE fp)2． 功能说明在文本文件（ASCII文件）中可以用值为-1的符号常量EOF来作为文件的结束符。但是在二进制文件中-1往往可能是一个有意义的数据，因此不能用它 来作为文件的结束标志。为了能有效判别文件是否结束，ANSI C提供了标准函数feof()，用来识别文件是否结束。3． 参数说明fp：文件指针。4． 返回值返回为非0值：已到文件尾。返回为0值：表示还未到文件尾。]]></content>
      <categories>
        <category>CPlus</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C语言文件读写操作总结]]></title>
    <url>%2F2017%2F02%2F16%2Fc-e8-af-ad-e8-a8-80-e6-96-87-e4-bb-b6-e8-af-bb-e5-86-99-e6-93-8d-e4-bd-9c-e6-80-bb-e7-bb-93%2F</url>
    <content type="text"><![CDATA[http://blog.csdn.net/strongwangjiawei/article/details/7786085 C语言文件读写操作总结C语言文件操作一、标准文件的读写1.文件的打开fopen() 文件的打开操作表示将给用户指定的文件在内存分配一个FILE结构区，并将该结构的指针返回给用户程序，以后用户程序就可用此FILE指针来实现对指定文件的存取操作了。当使用打开函数时，必须给出文件名、文件操作方式(读、写或读写),如果该文件名不存在，就意味着建立(只对写文件而言，对读文件则出错)，并将文件指针指向文件开头。若已有一个同名文件存在，则删除该文件，若无同名文件，则建立该文件，并将文件指针指向文件开头。fopen(char filename,char type);其中filename是要打开文件的文件名指针，一般用双引号括起来的文件名表示，也可使用双反斜杠隔开的路径名。而type参数表示了对打开文件的操作方式。其可采用的操作方式如下： 方式 含义 “r” 打开，只读； “w” 打开，文件指针指到头，只写； “a” 打开，指向文件尾，在已存在文件中追加； “rb” 打开一个二进制文件，只读； “wb” 打开一个二进制文件，只写； “ab” 打开一个二进制文件，进行追加 ；”r+” 以读/写方式打开一个已存在的文件； “w+” 以读/写方式建立一个新的文本文件 ；”a+” 以读/写方式打开一个文件文件进行追加 ；”rb+” 以读/写方式打开一个二进制文件； “wb+” 以读/写方式建立一个新的二进制文件 ；”ab+” 以读/写方式打开一个二进制文件进行追加 ；当用fopen()成功的打开一个文件时，该函数将返回一个FILE指针，如果文件打开失败，将返回一个NULL指针。如想打开test文件，进行写：123456789FILE *fp;if((fp=fopen(“test”,“w”))==NULL) &#123;printf(“File cannot be opened/n”);exit();&#125;elseprintf(“File opened for writing/n”);……fclose(fp);DOS操作系统对同时打开的文件数目是有限制的，缺省值为5，可以通过修改CONFIG.SYS文件改变这个设置。2.关闭文件函数fclose()文件操作完成后，必须要用fclose()函数进行关闭，这是因为对打开的文件进行写入时，若文件缓冲区的空间未被写入的内容填满，这些内容不会写到打开的文件中去而丢失。只有对打开的文件进行关闭操作时，停留在文件缓冲区的内容才能写到该文件中去，从而使文件完整。再者一旦关闭了文件，该文件对应的FILE结构将被释放，从而使关闭的文件得到保护，因为这时对该文件的存取操作将不会进行。文件的关闭也意味着释放了该文件的缓冲区。int fclose(FILE stream);它表示该函数将关闭FILE指针对应的文件，并返回一个整数值。若成功地关闭了文件，则返回一个0值，否则返回一个非0值。常用以下方法进行测试：123456if(fclose(fp)!=0) &#123;printf("File cannot be closed/n");exit(1);&#125;elseprintf("File is now closed/n");当打开多个文件进行操作，而又要同时关闭时，可采用fcloseall()函数，它将关闭所有在程序中打开的文件。 int fcloseall(); 该函数将关闭所有已打开的文件，将各文件缓冲区未装满的内容写到相应的文件中去，接着释放这些缓冲区，并返回关闭文件的数目。如关闭了4个文件，则当执行： n=fcloseall(); 时，n应为4。3.文件的读写(1).读写文件中字符的函数(一次只读写文件中的一个字符)：int fgetc(FILE stream);int getchar(void);int fputc(int ch,FILE stream);int putchar(int ch);int getc(FILE stream);int putc(int ch,FILE stream);其中fgetc()函数将把由流指针指向的文件中的一个字符读出，例如： ch=fgetc(fp); 将把流指针fp指向的文件中的一个字符读出，并赋给ch，当执行fgetc()函数时，若当时文件指针指到文件尾，即遇到文件结束标志EOF(其对应值为-1)，该函数返回一个-1给ch，在程序中常用检查该函数返回值是否为-1来判断是否已读到文件尾，从而决定是否继续。12345678910111213#include "stdio.h"#include &lt;stdlib.h&gt;int main() &#123;FILE *fp;char ch;if((fp=fopen("myfile.txt","r"))==NULL) &#123;printf("file cannot be opened/n");exit(1);&#125;while((ch=fgetc(fp))!=EOF)fputc(ch,stdout);fclose(fp);&#125;该程序以只读方式打开myfile.txt文件，在执行while循环时，文件指针每循环一次后移一个字符位置。用fgetc()函数将文件指针指定的字符读到ch变量中，然后用fputc()函数在屏幕上显示，当读到文件结束标志EOF时，关闭该文件。 上面的程序用到了fputc()函数，该函数将字符变量ch的值写到流指针指定的文件中去，由于流指针用的是标准输出(显示器)的FILE指针stdout，故读出的字符将在显示器上显示。又比如： fputc(ch,fp); 该函数执行结构，将把ch表示的字符送到流指针fp指向的文件中去。 在TC中，putc()等价于fputc(),getc()等价于fgetc()。 putchar(c)相当于fputc(c,stdout)；getchar()相当于fgetc(stdin)。 注意，这里使用char ch,其实是不科学的，因为最后判断结束标志时，是看ch!=EOF,而EOF的值为-1，这显然和char是不能比较的。所以，某些使用，我们都定义成int ch。(2).读写文件中字符串的函数char fgets(char string,int n,FILE stream);char gets(char s);int fprintf(FILE stream,char format,variable-list);int fputs(char string,FILE stream);int fscanf(FILE stream,char format,variable-list);其中fgets()函数将把由流指针指定的文件中n-1个字符，读到由指针string指向的字符数组中去，例如： fgets(buffer,9,fp); 将把fp指向的文件中的8个字符读到buffer内存区，buffer可以是定义的字符数组，也可以是动态分配的内存区。 注意，fgets()函数读到’/n’就停止，而不管是否达到数目要求。同时在读取字符串的最后加上’/0’。 fgets()函数执行完以后，返回一个指向该串的指针。如果读到文件尾或出错，则均返回一个空指针NULL，所以长用feof()函数来测定是否到了文件尾或者是ferror()函数来测试是否出错，例如下面的程序用fgets()函数读test.txt文件中的第一行并显示出来：12345678910111213#include "stdio.h"int main() &#123;FILE *fp;char str[128];if((fp=fopen("test.txt","r"))==NULL) &#123;printf("cannot open file/n"); exit(1);&#125;while(!feof(fp)) &#123;if(fgets(str,128,fp)!=NULL)printf("%s",str);&#125;fclose(fp);&#125;gets()函数执行时，只要未遇到换行符或文件结束标志，将一直读下去。因此读到什么时候为止，需要用户进行控制，否则可能造成存储区的溢出。 fputs()函数想指定文件写入一个由string指向的字符串，’/0’不写入文件。 fprintf()和fscanf()同printf()和scanf()函数类似，不同之处就是printf()函数是想显示器输出，fprintf()则是向流指针指向的文件输出；fscanf()是从文件输入。 下面程序是向文件test.dat里输入一些字符：12345678910111213#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() &#123;char *s="That's good news";int i=617;FILE *fp;fp=fopen("test.dat", "w"); /建立一个文字文件只写/fputs("Your score of TOEFL is",fp); /向所建文件写入一串字符/fputc(':', fp); /向所建文件写冒号:/fprintf(fp, "%d/n", i); /向所建文件写一整型数/fprintf(fp, "%s", s); /向所建文件写一字符串/fclose(fp);&#125;用DOS的TYPE命令显示TEST.DAT的内容如下所示: 屏幕显示 Your score of TOEFL is: 617 That’s good news 下面的程序是把上面的文件test.dat里的内容在屏幕上显示出来：123456789101112131415#include &lt;stdio.h&gt;int main() &#123;char s[24], m[20];int i;FILE *fp;fp=fopen("test.dat", "r"); /打开文字文件只读/fgets(s, 24, fp); /从文件中读取23个字符/printf("%s", s);fscanf(fp, "%d", &amp;i); /读取整型数/printf("%d", i);putchar(fgetc(fp)); /读取一个字符同时输出/fgets(m, 17, fp); /读取16个字符/puts(m); /输出所读字符串/fclose(fp);&#125;运行后屏幕显示: Your score of TOEFL is: 617 That’s good news4.清除和设置文件缓冲区(1).清除文件缓冲区函数：int fflush(FILE stream);int flushall();fflush()函数将清除由stream指向的文件缓冲区里的内容，常用于写完一些数据后，立即用该函数清除缓冲区，以免误操作时，破坏原来的数据。 flushall()将清除所有打开文件所对应的文件缓冲区。(2).设置文件缓冲区函数void setbuf(FILE stream,char buf);void setvbuf(FILE stream,char buf,int type,unsigned size);这两个函数将使得打开文件后，用户可建立自己的文件缓冲区，而不使用fopen()函数打开文件设定的默认缓冲区。 对于setbuf()函数，buf指出的缓冲区长度由头文件stdio.h中定义的宏BUFSIZE的值决定，缺省值为512字节。当选定buf为空时，setbuf函数将使的文件I/O不带缓冲。而对setvbuf函数，则由malloc函数来分配缓冲区。参数size指明了缓冲区的长度(必须大于0),而参数type则表示了缓冲的类型，其值可以取如下值： type 值 含义 _IOFBF 文件全部缓冲，即缓冲区装满后，才能对文件读写 _IOLBF 文件行缓冲，即缓冲区接收到一个换行符时，才能对文件读写 _IONBF 文件不缓冲，此时忽略buf,size的值，直接读写文件，不再经过文件缓冲区缓冲。5.文件的随机读写函数前面介绍的文件的字符/字符串读写，均是进行文件的顺序读写，即总是从文件的开头开始进行读写。这显然不能满足我们的要求，C语言提供了移动文件指针和随机读写的函数，它们是：(1).移动文件指针函数：long ftell(FILE stream);int rewind(FILE stream);fseek(FILE stream,long offset,int origin);函数ftell()用来得到文件指针离文件开头的偏移量。当返回值是-1时表示出错。 rewind()函数用于文件指针移到文件的开头，当移动成功时，返回0，否则返回一个非0值。 fseek()函数用于把文件指针以origin为起点移动offset个字节，其中origin指出的位置可有以下几种：origin 数值 代表的具体位置SEEK_SET 0 文件开头SEEK_CUR 1 文件指针当前位置SEEK_END 2 文件尾例如： fseek(fp,10L,0); 把文件指针从文件开头移到第10字节处，由于offset参数要求是长整型数，故其数后带L。fseek(fp,-15L,2); 把文件指针从文件尾向前移动15字节。(2).文件随机读写函数int fread(void ptr,int size,int nitems,FILE stream);int fwrite(void ptr,int size,int nitems,FILE stream);fread()函数从流指针指定的文件中读取nitems个数据项，每个数据项的长度为size个字节，读取的nitems数据项存入由ptr指针指向的内存缓冲区中，在执行fread()函数时，文件指针随着读取的字节数而向后移动，最后移动结束的位置等于实际读出的字节数。该函数执行结束后，将返回实际读出的数据项数，这个数据项数不一定等于设置的nitems，因为若文件中没有足够的数据项，或读中间出错，都会导致返回的数据项数少于设置的nitems。当返回数不等于nitems时，可以用feof()或ferror()函数进行检查。 fwrite()函数从ptr指向的缓冲区中取出长度为size字节的nitems个数据项，写入到流指针stream指向的文件中，执行该操作后，文件指针将向后移动，移动的字节数等于写入文件的字节数目。该函数操作完成后，也将返回写入的数据项数。二、非标准文件的读写这类函数最早用于UNIX操作系统,ANSI标准未定义,但有时也经常用到,DOS 3.0以上版本支持这些函数。它们的头文件为io.h。 由于我们不常用这些函数，所以在这里就简单说一下。1.文件的打开和关闭open()函数的作用是打开文件,其调用格式为: int open(char filename, int access); 该函数表示按access的要求打开名为filename的文件,返回值为文件描述字,其中access有两部分内容: 基本模式和修饰符, 两者用” “(“或”)方式连接。修饰符可以有多个, 但基本模式只能有一个。 access的规定 ——————————————————– 基本模式 含义 修饰符 含 义 ——————————————————– O_RDONLY 只读 O_APPEND 文件指针指向末尾 O_WRONLY 只写 O_CREAT 文件不存在时创建文件, 属性按基本模式属性 O_RDWR 读写 O_TRUNC 若文件存在, 将其长度缩为0, 属性不变 O_BINARY 打开一个二进制文件 O_TEXT 打开一个文字文件 ——————————————————— open()函数打开成功, 返回值就是文件描述字的值(非负值), 否则返回-1。 close()函数的作用是关闭由open()函数打开的文件, 其调用格式为: int close(int handle); 该函数关闭文件描述字handle相连的文件。2.读写函数int read(int handle, void buf, int count);read()函数从handle(文件描述字)相连的文件中, 读取count个字节放到buf所指的缓冲区中, 返回值为实际所读字节数, 返回-1表示出错。返回0 表示文件结束。 write()函数的调用格式为: int write(int handle, void buf, int count); write()函数把count个字节从buf指向的缓冲区写入与handle相连的文件中, 返回值为实际写入的字节数。3.随机定位函数lseek()函数的调用格式为: int lseek(int handle, long offset, int fromwhere);该函数对与handle相连的文件位置指针进行定位,功能和用法与fseek()函数相同。 tell()函数的调用格式为: long tell(int handle); 该函数返回与handle相连的文件现生位置指针, 功能和用法与ftell()相同5. read 函数和 write 函数来源：蚂蚁的 C/C++ 标准编程 作者：antigloss1. read#include ssize_t read(int filedes, void buf, size_t nbytes); 返回值：读取到的字节数；0（读到 EOF）；-1（出错） read 函数从 filedes 指定的已打开文件中读取 nbytes 字节到 buf 中。以下几种情况会导致读取到的字节数小于 nbytes ：A. 读取普通文件时，读到文件末尾还不够 nbytes 字节。例如：如果文件只有 30 字节，而我们想读取 100 字节，那么实际读到的只有 30 字节，read 函数返回 30 。此时再使用 read 函数作用于这个文件会导致 read 返回 0 。B. 从终端设备（terminal device）读取时，一般情况下每次只能读取一行。C. 从网络读取时，网络缓存可能导致读取的字节数小于 nbytes 字节。D. 读取 pipe 或者 FIFO 时，pipe 或 FIFO 里的字节数可能小于 nbytes 。E. 从面向记录（record-oriented）的设备读取时，某些面向记录的设备（如磁带）每次最多只能返回一个记录。 F. 在读取了部分数据时被信号中断。读操作始于 cfo 。在成功返回之前，cfo 增加，增量为实际读取到的字节数。2. write#include ssize_t write(int filedes, const void *buf, size_t nbytes); 返回值：写入文件的字节数（成功）；-1（出错）write 函数向 filedes 中写入 nbytes 字节数据，数据来源为 buf 。返回值一般总是等于 nbytes，否则就是出错了。常见的出错原因是磁盘空间满了或者超过了文件大小限制。 对于普通文件，写操作始于 cfo 。如果打开文件时使用了 O_APPEND，则每次写操作都将数据写入文件末尾。成功写入后，cfo 增加，增量为实际写入的字节数。]]></content>
      <categories>
        <category>CPlus</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[如何优雅地使用Sublime Text3]]></title>
    <url>%2F2017%2F02%2F12%2Fe5-a6-82-e4-bd-95-e4-bc-98-e9-9b-85-e5-9c-b0-e4-bd-bf-e7-94-a8sublime-text3%2F</url>
    <content type="text"><![CDATA[http://www.jianshu.com/p/3cb5c6f2421c 作者 晚晴幽草 关注 2015.04.17 22:56 字数 7389 阅读 152138评论 101喜欢 456 Sublime Text：一款具有代码高亮、语法提示、自动完成且反应快速的编辑器软件，不仅具有华丽的界面，还支持插件扩展机制，用她来写代码，绝对是一种享受。相比于难于上手的Vim，浮肿沉重的Eclipse，VS，即便体积轻巧迅速启动的Editplus、Notepad++，在SublimeText面前大略显失色，无疑这款性感无比的编辑器是Coding和Writing最佳的选择，没有之一。 温情提醒：可以移步原文首链处：如何优雅地使用Sublime Text(因为那儿还在持续更新完善中)；Here最后更新于2015.12.15晚 (不能为简书文章添加目录？，额，折腾不出来，醉了)，但目录结构还是可以有的： 如何优雅地使用Sublime Text 之 目录结构 Sublime Text 2和3的对比 Sublime Text 3安装插件 Sublime Text 3插件推荐 定制属于自己的快捷键 Sublime不可不知的实用技巧 定制属于自己的个性化主题 Sublime锦上添花些许设置 写在一路更来的结语 Sublime Text 2和3的对比相比于2，Sublime Text 3就秒启动一项，就压倒性地胜利了。因此在之后的叙述中都以Sublime Text 3为主角。并且3一直在不断的完善更新，具体的差异可参看Sublime Blog.简单的说： ST3支持在项目目录里面寻找变量 提供了对标签页更好地支持（更多的命令和快捷键） 加快了程序运行的速度 更新了API，使用Python3.3强烈推荐朋友们使用3! 唯快不破，不解释。 Sublime Text 3安装插件Sublime Text的强大就是她拥有强大的课可扩展性。您可根据自己的需要安装不同的插件；这使得她变的无比强大的同时又不失轻便。 插件安装方式一：直接安装： 安装Sublime text 3插件很方便，可以直接下载安装包解压缩到Packages目录（菜单-&gt;preferences-&gt;packages）。 插件安装方式二：使用Package Control组件安装： 按Ctrl+`调出console（注：安装有QQ输入法的这个快捷键会有冲突的，输入法属性设置-输入法管理-取消热键切换至QQ拼音）粘贴以下代码到底部命令行并回车： &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; urllib.request,os; pf = &lt;span class=&quot;hljs-string&quot;&gt;&apos;Package Control.sublime-package&apos;&lt;/span&gt;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), &lt;span class=&quot;hljs-string&quot;&gt;&apos;wb&apos;&lt;/span&gt;).write(urllib.request.urlopen( &lt;span class=&quot;hljs-string&quot;&gt;&apos;http://sublime.wbond.net/&apos;&lt;/span&gt; + pf.replace(&lt;span class=&quot;hljs-string&quot;&gt;&apos; &apos;&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;&apos;%20&apos;&lt;/span&gt;)).read())`&lt;/pre&gt; 重启Sublime Text 3。如果在Perferences-&amp;gt;package settings中看到package control这一项，则安装成功。按下Ctrl+Shift+P调出命令面板输入install 调出 Install Package 选项并回车，然后在列表中选中要安装的插件。 PS：国内使用SublimeText3，经常可能遇到无法安装可用插件问题，可remove掉Package Control重新安装下；如遇到连Package Control也无法安装，则可以在别处拷贝一份关于Package Control的文件－(Package Control.sublime-package)存放于Installed Packages目录之下即可。 Sublime Text 3插件推荐无插件，不神器！根据自己的需要定制属于自己的强大插件集；作为在移动端旧游之后，又Web端新游的自己，墙裂推荐以下这么几款插件：MarkDown EditingSublimeText不仅仅是能够查看和编辑 Markdown 文件，但它会视它们为格式很糟糕的纯文本。这个插件通过适当的颜色高亮和其它功能来更好地完成这些任务。关于如何在SublimeText下高效些东西可参见文章：sublime text 2(3)下的Markdown写作 抑或是前段时间写下的追寻高效工作的一路折腾㈡ SideBarFolders打开的文件夹都太多了? 来用这个来管理文件夹，世界原来也可以这么美好。SideBarFoldersSublime Terminal这个插件可以让你在Sublime中直接使用终端打开你的项目文件夹，并支持使用快捷键。 ColorPicker通常，如果你想使用一个颜色选择器则可能打开 Photoshop 或 GIMP。而在 Sublime Text 中，你可以使用内置的颜色选择器。安装完成后，只要按下Ctrl / Cmd + Shift + C 快捷键。 SublimeREPL这可能是对程序员很有用的插件。SublimeREPL 允许你在 Sublime Text 中运行各种语言（NodeJS ， Python，Ruby， Scala 和 Haskell 等等）。 Ctags插件有童鞋抱怨Sublime Text不能支持函数的跳转（比如像Eclipse那样，按住Control点击该方法或者对象，即可跳转到定义的地方； Alt+←即可回到原处）。其实Sublime Text也可以借助插件实现之（当然，有些情况下:Can not find defination）毕竟这个也是借助正则来匹配完成的。因此这个也就要求代码很规范。这个插件相对来讲会有些麻烦，具体的可以参见:Sublime Text ctags 的配置. SublimeLinter插件SublimeLinter 是前端编码利器——Sublime Text 的一款插件，用于高亮提示用户编写的代码中存在的不规范和错误的写法，支持 JavaScript、CSS、HTML、Java、PHP、Python、Ruby 等十多种开发语言。这篇文章介绍如何在 Windows 中配置 SublimeLinter 进行 JS &amp; CSS 校验。比如写例如像lua这样的弱语言脚本代码，有这个可以规避掉很多不该有的低级错误吧？当然这也需要你SublimeLinter安装完毕之后再安装一个SublimeLinter-lua即可。具体的使用可以参见：借助 SublimeLinter 编写高质量的 JavaScript &amp; CSS 代码 SideBarEnhancements插件SideBarEnhancements是一款很实用的右键菜单增强插件；在安装该插件前，在Sublime Text左侧FOLDERS栏中点击右键，只有寥寥几个简单的功能；安装了就相当于给其丰了大胸一般。 更强大的是，该插件还能让我们自定义快捷键呼出某个浏览器以预览页面！这样就不用到项目目录下寻找和拖动到特定浏览器中预览了。安装此插件后，点击菜单栏的preferences-&gt;package setting-&gt;side bar-&gt;Key Building-User，键入以下代码：`[ { &lt;span class=&quot;hljs-string&quot;&gt;&quot;keys&quot;&lt;/span&gt;: [&lt;span class=&quot;hljs-string&quot;&gt;&quot;ctrl+shift+c&quot;&lt;/span&gt;], &lt;span class=&quot;hljs-string&quot;&gt;&quot;command&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;copy_path&quot;&lt;/span&gt; }, //chrome { &lt;span class=&quot;hljs-string&quot;&gt;&quot;keys&quot;&lt;/span&gt;: [&lt;span class=&quot;hljs-string&quot;&gt;&quot;f2&quot;&lt;/span&gt;], &lt;span class=&quot;hljs-string&quot;&gt;&quot;command&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;side_bar_files_open_with&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;args&quot;&lt;/span&gt;: { &lt;span class=&quot;hljs-string&quot;&gt;&quot;paths&quot;&lt;/span&gt;: [], &lt;span class=&quot;hljs-string&quot;&gt;&quot;application&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;C:\\Users\\jeffj\\AppData\\Local\\Google\\Chrome\\Application\\chrome.exe&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;extensions&quot;&lt;/span&gt;:&lt;span class=&quot;hljs-string&quot;&gt;&quot;.*&quot;&lt;/span&gt; } } ]`这里设置按Ctrl+Shift+C复制文件路径，按F2即可在Chrome浏览器预览效果(如果需要的话，也可以根据自己的需要为Firefox，Safari，IE，Opera等加上)，当然你也可以自己定义喜欢的快捷键，最后注意代码中的浏览器路径要以自己电脑里的文件路径为准。 HTML-CSS-JS Prettify一款集成了格式化（美化）html、css、js三种文件类型的插件，即便html,js写在PHP文件之内。插件依赖于nodejs，因此需要事先安装nodejs，然后才可以正常运行。插件安装完成后，快捷键ctrl+shift+H完成当前文件的美化操作。插件对html、css文件的美化不是非常满意，但还可以，后面将说明如何修改css美化脚本。本人用起来超级爽的，鉴于篇幅，就不赘述，可以参见这篇介绍。 CSScomb CSS属性排序:有时候看看自己写的CSS文件，会不会觉得属性很乱查找不易维护难？CSScomb可以按照一定的CSS属性排序规则，将杂乱无章的CSS属性进行重新排序。选中要排序的CSS代码，按Ctrl+Shift+C，即可对CSS属性重新排序了，代码从此简洁有序易维护，如果不款选代码则插件将排序文件中所有的CSS属性。当然，可以自己自定义CSS属性排序规则，打开插件目录里的CSScomb.sublime-settings文件，更改里面的CSS属性顺序就行了。因为这个插件使用PHP写的，要使他工作需要在环境变量中添加PHP的路径，具体请看github上的说明。 SublimeTmpl 快速生成文件模板一直都很奇怪为什么sublime text 3没有新建文件模板的功能，像html头部的DTD声明每次都要复制粘贴。用SublimeTmpl这款插件终于可以解脱了，SublimeTmpl能新建html、css、javascript、php、python、ruby六种类型的文件模板，所有的文件模板都在插件目录的templates文件夹里，可以自定义编辑文件模板。SublimeTmpl默认的快捷键:ctrl+alt+h &lt;span class=&quot;hljs-selector-tag&quot;&gt;html&lt;/span&gt; ctrl+alt+j javascript ctrl+alt+c css ctrl+alt+&lt;span class=&quot;hljs-selector-tag&quot;&gt;p&lt;/span&gt; php ctrl+alt+r ruby ctrl+alt+shift+&lt;span class=&quot;hljs-selector-tag&quot;&gt;p&lt;/span&gt; python如果想要新建其他类型的文件模板的话，先自定义文件模板方在templates文件夹里，再分别打开Default (Windows).sublime-keymap、Default.sublime-commands、Main.sublime-menu、SublimeTmpl.sublime-settings这四个文件照着里面的格式自定义想要新建的类型，这里就详细介绍了，请各位自己折腾哈~ Javascript-API-Completions:支持Javascript、JQuery、Twitter Bootstrap框架、HTML5标签属性提示的插件，是少数支持sublime text 3的后缀提示的插件，HTML5标签提示sublime text3自带，不过JQuery提示还是很有用处的，也可设置要提示的语言。sublime-jq-pluginSFTP：快速编辑远程服务器文件在Win下用Xftp 和 WinScp，被这种需要切换点击or F5刷新的手动操作蛋疼到无语；故此一遇见这SFTP，顿觉这世界都美好了许多。当然Sublime下面也有些其他同步插件，比如FtpSnyc，但是配置起来的错误提示一点都不人性化，就毫不留情的舍弃了。Sublime下有SFTP，只要Ctrl+S即可同步本地到服务器，妥妥的爽歪歪有么有？如何配置，请参见在 Sublime Text中使用 SFTP 插件快速编辑远程服务器文件;如欲使用FtpSync可参见Sublime使用及FtpSync远程同步；大道至简，因简而悦；开心垒码，值得折腾。 WakaTime – 记录你的Code时间;WakaTime可以做到精确地统计到你花在某个项目上的时间;WakaTime针对不同的IDE，拥有不同的插件，在Sublime上安装着插件，就能统计到我使用Sublime进行的所有项目的行为。可以高效管理和知晓自己code时间；并且，统计完善, 适合发朋友圈装逼（如果你喜欢的话）~ Waka的基本设计和rescuetime类似。每个人注册完将获取一个key，装一个客户端，把key输进去（登陆是同一个道理），然后它就把本地的所有行为带个key扔给服务器来统计，一段时间之后给你个报表。不过Waka做的真的很精准，精确到每一个文件用了多少秒，每一种语言用了多少时间。安装和使用都很简单，请参见这里。另外一篇比较详细的文章时间都去哪了?用RescueTime和WakaTime来记录你的时间,对RescueTime和WakaTime有一个更为详细的叙述，可以一读。 Doc​Blockr: 代码块注释可以快速的对函数进行注释。保持代码规范。支持多种语言,有 JavaScript (including ES6), PHP, ActionScript, Haxe, CoffeeScript, TypeScript, Java, Apex, Groovy, Objective C, C, C++ and Rust. /*:回车创建一个代码块注释 /**:回车在自动查找函数中的形参等等。它会生成 JSDoc 格式的注释。如果你从没有使用过类似的工具，DocBlockr 会让你觉得以前没有它是如何写代码的。帮助你创造你的代码注释，通过解析功能，参数，变量，并且自动添加基本项目；如果你愿意其更为便捷，不妨再结合AutoHotKey,高效注释，由此开启。 sublime-text-git: Git 版本控制可视化的操作：帮助你与你的Git repo协议进行交互。它支持很多命令像init,push, pull, branch, stash,等等。使用它当然提前需要安装 Git，并做好响应的配置；对于这个插件，不妨看下这篇文章 Using Git Inside of Sublime Text to Improve Workflow，相信她的伴随不会让你失望的。 advancedNewFile： 快速创建文件当我们在 Sublime Text 编辑器里我们可以通过快捷键command+n(win: ctrl+n),来新建一个文件，然后command+s(Win:ctrl+s)进行弹出保存框，填写文件名进行保存。还是老问题，麻烦！！我们接下来就通过安装advancedNewFile插件来提升我们在Sublime Text编辑器下的创建文件速度。 关乎其使用，安装完成之后，运用快捷键command+alt+n(win: ctrl+alt+n)，Sublime Text底部会弹出输入框；我们只需在这个输入框里输入我们需要新建的文件名回车即可（我们甚至可以带路径,譬如:src/components/perfect.vue;这就会在当前项目目录下，建立该文件；需要注意的是这路径前面不可加 ‘/‘, 这会使得建立的路径成为用户目录，而非改项目目录）。默认情况下文件会存储在当前目录，如果当前没有目录，会存储在用户的家目录。 剩下些许其他的可以按需安装的插件，比如： ConvertToUTF8 支持 GBK, BIG5, EUC-KR, EUC-JP, Shift_JIS 等编码的插件 Bracket Highlighter 用于匹配括号，引号和html标签。对于很长的代码很有用。安装好之后，不需要设置插件会自动生效 DocBlockr 可以自动生成PHPDoc风格的注释。它支持的语言有Javascript, PHP, ActionScript, CoffeeScript, Java, Objective C, C, C++ &lt;font color=”purple”&gt;Emmet(Zen Coding)&lt;/font&gt;快速生成HTML代码段的插件，强大到无与伦比:可以超快速编写HTML/CSS/JS，当然这个插件还支持多种编译环境，如常见的：Eclipse/Aptana、Coda、Notepad++、Adobe Dreamweaver、TextMate等，web开发必备！！！。 jsFormat 格式化js代码，懂者自懂；强迫症Coder必备！默认快捷键Ctrl+Alt+F。 phpFormat 格式化php代码，懂者自懂；强迫症Coder必备！ CSS Compact Expand CSS属性展开收缩:写CSS的盆友，喜欢将其写多行还是一行(个人喜欢将其格式化为多行)？如果阅读别人的代码不符合自己的习惯，可以用CSS Compact Expand这个插件将CSS格式化一下，按 Ctrl+Alt+[ 收缩CSS代码为一行显示，按 Ctrl+Alt+] 展开CSS代码为多行显示；强迫症Coder必备！。 Autoprefixer插件：这是一款CSS3私有前缀自动补全插件；该插件使用CanIUse资料库（当然，SublimeText自然也有&lt;font color=”purple”&gt;CanIUse&lt;/font&gt;这个插件咯），能精准判断哪些属性需要什么前缀，与CssComb插件一样，该插件也需要系统已安装Node.js环境；使用方法：在输入CSS3属性后（冒号前）按Tab键即可。 YUI Compressor：压缩JS和CSS文件，按F7键后，若压缩当前文件（demo.js），则压缩后的文件（demo.min.js）保存在该文件的同级目录，需要安装java的JDK。使用方法：YUI Compressor ClickableURLs：可点击的URL使用小插件ClickableURLs可以让文件中的URL能够点击。 Vue Syntax Highlight: Vue(.vue)高亮插件；于前端而言，使用Vue框架开发，是一个很酷爽的存在，那么此插件也就很有必要拥有；同时Jade, SASS等插件也是很有拥有的必要，谁用谁知道(说到用vue, 这vue-cli就蛮有使用的必要了( Webpack, Eslint, Test等都配置完善，十分贴心); 而写Js代码，于稍大项目 Eslint 就很有使用必要，而 sublime 在针对使用 Eslint 的 `.vue`文件，目测还没有很好格式化插件，坐等诞生&#x1f633;)。 终极王道：自己编写专用的Sublime Text插件。虽然说各个方面比如移动端，Web前段，服务器端，非Coder的Writer所需要的方便已经被集成在了不同的插件中。但譬如，需要快捷打开PC端的某个模拟器，便捷的进行某些校验，只要你想的到的基本都可以将其在插件内，以快捷键处理之。至于如何编写SublimeText插件，请参看这里编写自己的Sublime Text2 插件 定制属于自己的快捷键 首先要会使用SublimeText内置的快捷键：比如 Commond Shift P 打开命令面板:例如打开Package Control安装各种插件；可以可以输入Set(Snytax)来改变使用的语言环境，瞬间切换等等。 设置快捷键。在SublimeText里，打开Preferences -&gt; Key Bindings - User，我设置的快捷键：` [{ &lt;span class=&quot;hljs-attr&quot;&gt;&quot;keys&quot;&lt;/span&gt;: [&lt;span class=&quot;hljs-string&quot;&gt;&quot;ctrl+f9&quot;&lt;/span&gt;], &lt;span class=&quot;hljs-attr&quot;&gt;&quot;command&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;build&quot;&lt;/span&gt; }, { &lt;span class=&quot;hljs-attr&quot;&gt;&quot;keys&quot;&lt;/span&gt;: [&lt;span class=&quot;hljs-string&quot;&gt;&quot;f10&quot;&lt;/span&gt;], &lt;span class=&quot;hljs-attr&quot;&gt;&quot;command&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;build&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-attr&quot;&gt;&quot;args&quot;&lt;/span&gt;: {&lt;span class=&quot;hljs-attr&quot;&gt;&quot;variant&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;Run&quot;&lt;/span&gt;} }, { &lt;span class=&quot;hljs-attr&quot;&gt;&quot;keys&quot;&lt;/span&gt;: [&lt;span class=&quot;hljs-string&quot;&gt;&quot;ctrl+shift+x&quot;&lt;/span&gt;], &lt;span class=&quot;hljs-attr&quot;&gt;&quot;command&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;toggle_comment&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-attr&quot;&gt;&quot;args&quot;&lt;/span&gt;: { &lt;span class=&quot;hljs-attr&quot;&gt;&quot;block&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt; } }, ]`具体可参见这边文章Sublime Text3 快捷键汇总及设置快捷键配置环境变量 定制属于自己的专属快捷键：比如就拿定制Sublime Text(2/3)编译lua 的快捷键来说： * 首先：下安装lua环境(MAC) `curl -s https://raw.githubusercontent.com/rudix-mac/rpm/2014.10/rudix.py | sudo python - install rudix 或者：curl -O https://raw.githubusercontent.com/rudix-mac/rpm/2014.10/rudix.pysudo python rudix.py install rud` 安装IED：SublimeText3;完毕后上面选择:Build System–New Build System 输入：{ &lt;span class=&quot;hljs-attr&quot;&gt;&quot;cmd&quot;&lt;/span&gt;: [&lt;span class=&quot;hljs-string&quot;&gt;&quot;/usr/local/bin/lua&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;$file&quot;&lt;/span&gt;], &lt;span class=&quot;hljs-attr&quot;&gt;&quot;file_regex&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;^(...*?):([0-9]*):?([0-9]*)&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-attr&quot;&gt;&quot;selector&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;source.lua&quot;&lt;/span&gt; }保存为Lua.sublime-build，然后Tools-Build System上就能选择lua来编译脚本了）PS：网上找到的大多数都是 “cmd”: [“lua”, “$file”]可能我是用rudix自动来安装lua的，需要改一下路径。 新建一个xx.lua文件，随便写个语句，选择lua为build system，按一下command+b，就能跑出来了。 如下图所示：LuaShortCutSublimeTextWindowS下面的定制请参看这里Sublime Text(2/3)编译lua Sublime不可不知的实用技巧:—更新2015.05.21 15:50 ShenZhen@nanshan对于这个依赖于插件的强大性感无比开源编辑器；优雅的适用之，就在于合理的使用需要的插件，走一条快准狠的键盘一刀流。这个当然可以自己用python来写，但是一般的需求基本上都已经有人完成，还是不浪费时间自己造轮子了。今儿就再赘述一些使用的经验，让使用她可以更加优雅。(1) Ctrl+O(Command+O)可以实现头文件和源文件之间的快速切换(2) 通过 View -&gt; Side bar 可在左侧显示当前打开的文件列表 (3) ST3虽然不像notepad++可以在sidebar上显示函数列表，但是可通过Ctrl+R查看 (3) 通过 Preference -&gt; Key binding user 可根据个人操作习惯自定义快捷键（包括ST3自带的和插件的） (4) 双击可选中光标所在单词，三击可选中光标所在行(等同于Ctrl＋L(Command+L)); (5) Ctrl+Shift+T可以打开之前关闭的tab页，这点同chrome是一样的 (6)Ctrl+R定位函数；Ctrl+G定位到行； (7) 单个文件批量修改：纯相同的内容：选中需要修改的内容Alt+F3(Mac下默认的是Ctrl+Command+G) ， 或者连续 Ctrl+D(Win) /连续 Command+D（Mac）之后重新写即可，使用Ctrl + U进行回退，使用Esc退出多重编辑。 不纯相同却有一定规律可循的内容：这个就需要借助SublimeText强大正则的支持了。可以使用Ctrl+H(Mac下是Alt+Command+F)调出：SublimeText正则表达式是非常强大的文本查找&amp;替换工具，Sublime Text中使用Alt + R切换正则匹配模式的开启/关闭。Sublime Text的使用Boost里的Perl正则表达式风格。鉴于篇幅，加之本身就对这个不甚熟悉，这里就不再多啰嗦；以下是一些可以参考的文章： 开源中国～正则表达式30分钟入门教程 59分钟学会正则表达式 MSDN～正则表达式语法.aspx) 月光博客～常用正则表达式(8) 有时我们需要对一片区域的所有行进行同时编辑，Ctrl+Shift+L可以将当前选中区域打散，然后进行同时编辑：SublimeText(9)有打散自然就有合并，Ctrl + J(mac下Command＋J)可以把当前选中区域合并为一行：SublimeText(10)在Ctrl + P(Command+P)匹配到文件后，我们可以进行后续输入以跳转到更精确的位置： @ 符号跳转：输入@symbol跳转到symbol符号所在的位置 关键字跳转：输入#keyword跳转到keyword所在的位置 : 行号跳转：输入:12跳转到文件的第12行。(11)Ctrl + Enter(Mac~Command+Enter)在当前行下面新增一行然后跳至该行；Ctrl + Shift + Enter在当前行上面增加一行并跳至该行。 (12)Sublime Text的查找有不同的模式：Alt + C切换大小写敏感（Case-sensitive）模式，Alt + W切换整字匹配（Whole matching）模式，除此之外Sublime Text还支持在选中范围内搜索（Search in selection），这个功能没有对应的快捷键，但可以通过以下配置项自动开启。 “auto_find_in_selection”: true这样之后在选中文本的状态下范围内搜索就会自动开启，配合这个功能，局部重命名（Local Renaming）变的非常方便：SublimeText(13)Windows下Ctrl + ←/→进行逐词移动，相应的，Ctrl + Shift + ←/→进行逐词选择。SublimeText而Mac下的Command+←/→是从一端移动到另一端；相应的，Command + Shift + ←/→是从一端选择到另一端。 (14) Windows下Ctrl + ↑/↓移动当前显示区域，Ctrl + Shift + ↑/↓移动当前行。SublimeText而Mac下的Command + ↑/↓是从当前行移动到头/尾；相应的，Command + Shift + ↑/↓是从当前行选择到头/尾； (15)使用Ctrl + N在当前窗口创建一个新标签，Ctrl + W关闭当前标签，Ctrl + Shift + T恢复刚刚关闭的标签。 (16)编辑代码时我们经常会开多个窗口，所以分屏很重要。Windows下：Alt + Shift + 2进行左右分屏，Alt + Shift + 8进行上下分屏，Alt + Shift + 5进行上下左右分屏（即分为四屏）。 (17)Sublime Text基本的手动格式化操作包括：Ctrl + [向左缩进(等同于将一块选中Shift+Tab)，Ctrl + ]向右缩进(等同于将一块选中后Tab键)，注解： Ctr+[ 和 Ctr+[ 针对一块连续内容使用，无需选中；此外Ctrl + Shift + V可以以当前缩进粘贴代码（非常实用）。 (18) Ctrl+Shift+V(好吧，尝试了下Windows下的这个，目测不行，看来须得安装下Clipboard-history插件～（粘贴板历史记录）才行啊)（Mac下Command＋Shift＋V），粘贴之时可以调出之前粘贴过的内容（以一个轻量弹框显示以供选择），哇哦，才发现这个功能，感觉棒棒哒&#x1f604;&#x1f604;。SublimeText(19) Sublime text 删除插件步骤：“Ctrl+Shift+P”—“Remove Package”—“找到需要删除的插件，并点击即可删除”; (20) 作为强大而小巧，性感且快捷的SublimeText，怎么能够允许不时弹个框提醒你购买或者别的，并且顶部有未注册这样破坏美感的存在呢？OK，输入Sublime text 3最新版破解方法中提供的注册码，就妥妥的哦了。 定制属于自己的个性化主题SublimeText 她不仅仅是作为性感无比，强大可大编辑器的存在；要知道在如今这么靠脸吃饭的时代，她的美者这方面怎么可能不臻至完美呢？Mac和Windows都默认十多种不同风格的主题，想必会有您喜欢&#x1f60d;的。即便没有也没关系，我们可以自己定制自己喜欢的风格主题。在线制作专属Sublime Text主题。这个网址可以轻松按照自己的意愿制作喜欢的主题。完毕之后将生成的xx.sublime.theme文件，点开Preferences -&gt; Browsr Packages这个，放在这个直属目录之下，即可在Theme处选择这个主题了，亲测没有问题。后记：作为如此便捷的她(Sublime Text3)，值得分享肯定不止这些，在Coding and Writing路上，要继续去发现和发扬她的美，未完待续…–写于2015.04.17 22:49 ShenZhen@nanshan Sublime锦上添花些许设置—更新2015.08.31 11:59 ShenZhen@nanshan— Sublime Text内运行javascript(ES6)首先安装nodejs当然你可以使用其它诸如jsc之类的环境来运行js, 本文使用的是nodejs. 首先确保你的电脑已经安装好nodejs, 并已将其添加到环境变量中 (一般安装时自动添加或者询问是否添加) 添加build system在sublime text中依次打开Tools -&gt; Build System -&gt; New Build System… 粘贴以下代码后保存(如Node.sublime-build), 然后把Build System设成Automatic{ “cmd”: [“node”, “–use-strict”, “–harmony”, “$file”], “selector”: “source.js”} 附加说明在以上的build文件中(Node.sublime-build), node是执行命令, –harmony和–use-strict是执行参数, $file是当前文件名, 所以一次build操作实际上相当于在命令行中执行了node –use-strict –harmony filename. –harmony表示启用ES Harmony features, 而这些features目前只能在strict模式下运行, 所以需要同时添加use-strict参数(详见what-is-extended-mode).如果不想启用es6的特性,把build文件更改成以下代码保存即可.{ “cmd”: [“node”, “$file”], “selector”: “source.js”} 具体使用在sublime test中新建一个test.js文件, 然后输入你的测试代码, 比如:`for (let i = 0; i &lt; 3; i++) { console.log(&lt;span class=&quot;hljs-string&quot;&gt;&apos;i:&apos;&lt;/span&gt;, i); }&lt;/pre&gt; 使用快捷键ctrl + b, 将得到以下执行结果: &lt;pre class=&quot;hljs groovy&quot;&gt;i: 0i: 1i: 2[Finished in 0.1s] 温馨注解: (1)文件必须是存在于磁盘中的, 而不是untitled的, 否则sublime无法找到相应的文件. (2)Nodejs安装目录需要加入path环境变量中，否则Ctrl+B运行 会出现：[WinError 2] 系统找不到指定的文件。 更换Sublime Text程序图标不仅主题可以更换，图标也可以。在Dribbble上有大量重新设计的Sublime Text精美图标。更换方法： 下载一个图标，有.icns格式的最好。如果没有，用iConvert转换之。 终端执行：open /Applications/Sublime\ Text.app/Contents/Resources/ 替换Sublime Text 3.icns或Sublime Text 2.icns文件。Sublime Sublime 拼写检查如果你经常使用SublimeText从事英文创作，那么启用拼写检查就非常有用处了。选择Preferences &amp;gt; Settings – User菜单，添加以下代码： “spell_check”: true, 写在一路更来的结语不得不说的是此篇文章的命名，较之于内容来讲是大了很多。毕竟要优雅使用某个工具，并不是件很容易的事。一边发现学习，一边总结更新，到此已5个月整。然而，对她～SublimeText3三的使用和了解也是仅仅限于一般水平而已。只能说：每个人都工具的使用都怀有不同的态度和追求；但是，工欲善其事，必先利其器；此一点总是没错的。因此，在投资自己这里，除学习知识之外，工具的使用大抵就是最应该投资学习的，再次可以是蓝股等等，一如Google工程师@徐宥工具的强是无敌的所言。所谓，一个好汉三个帮；欲要优雅使用一个工具，辅助器具是必不可少的。而在于Win下以SublimeText来编程或者写作，譬如AutoHotKey，Listary等对个人来讲着实已成必备工具(在Mac下，有Alfred在手，可以说是天下我有)；其给人带来的方便快捷和意想不到的惊喜，足以可以令其称为Win下小众软件中实用最。当然，像AutoHotKey这种在乎于人强，其功能愈发强的工具，其修行之路漫漫，还当上下以求索之(15.09.17更)。 当然，也不能盲目停留在SublimeText这孤傲的世界里。虽性感强大如斯，毕竟也已逝老牌儿范儿了。新的时代总会崛起些新秀，比如Github出品的Atom许有赶超Sublime之势，目测充盈着些许不同的理念；有时间定当去学习下，知乎有话题：如何评价 Github 发布的文本编辑器 Atom？，可预先了解下。 －－－2016-03-06日更新：一直以来特别钟爱Sublime的。可插件安装多了的SublimeText日益感觉微微有些卡顿感了。并且最近一次更新之后，频繁弹出的购买提示框也是很令人不舒服（以前网搜的注册码也显得力不从前）。而对Atom的近期试用情形来看，用的还蛮舒适，现在两者兼用之。前两天有随记下Atom使用感受：新编码神器Atom使用纪要有兴趣爱尝试下Atom的看官们，可供参考。 －－－2016-03-13日更新之前提到优雅使用SublimeText，也须结合如AutoHotKey，Listary这样一些小工具，方更见神奇 。使用AutoHotKey也有段日子了，虽没拿她来助我完成一些高大上复杂的事情，却无时无刻不帮着我节省一秒秒时间。趁着小闲，周五有将使用她的一些粗浅经验，凑成 Win下最爱效率神器:AutoHotKey一文，与诸君分享，希望有用，如此，足慰我心，善莫大焉。 最后寄语： 工欲善其事，必先利其器！ 公欲善其事，必先利其器！ 参考文章出处：Sublime Text 全程指引 by LucidaSublime Text 3能用支持的插件推荐Wakatime 测试工作时间Sublime Text3插件：增强篇20个强大的SublimeText插件 原文首贴链接:http://www.jeffjade.com/2015/12/15/2015-04-17-toss-sublime-text/ 您可能感兴趣(/有用)的文章： 那些所倚靠的利器记载 Awesome Chrome 插件集锦 Win下最爱效率神器:AutoHotKey Win下必备神器之Cmder 新编码神器Atom使用纪要 sublime text 下的Markdown写作 SublimeText下写作利器之MarkdownEditing Mac必备软件渐集之ZSH－终极Shell Vimium~让您的Chrome起飞 折腾&amp;探索© 著作权归作者所有举报文章关注晚晴幽草写了 128594 字，被 994 人关注，获得了 1758 个喜欢 个人简介 产自陕南一隅，流走于深圳的小雄猿。崇文喜武，爱美人尚科技；编码砌字，当下静…]]></content>
      <categories>
        <category>ide</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Sublime Text 3 3126 注册码]]></title>
    <url>%2F2017%2F02%2F12%2Fsublime-text-3-3126-e6-b3-a8-e5-86-8c-e7-a0-81%2F</url>
    <content type="text"><![CDATA[http://blog.csdn.net/wind520/article/details/52717070 Sublime Text 3 3126 注册码 第一个测试通过 —– BEGIN LICENSE —–Michael BarnesSingle User LicenseEA7E-8213858A353C41 872A0D5C DF9B2950 AFF6F667C458EA6D 8EA3C286 98D1D650 131A97ABAA919AEC EF20E143 B361B1E7 4C8B7F04B085E65E 2F5F5360 8489D422 FB8FC1AA93F6323C FD7F7544 3F39C318 D95E6480FCCC7561 8A4A1741 68FA4223 ADCEDE07200C25BE DBBC4855 C4CFB774 C5EC138C0FEC1CEF D9DCECEC D3A5DAD1 01316C36—— END LICENSE —— —– BEGIN LICENSE —–Free Communities Consultoria em Informática LtdaSingle User LicenseEA7E-801302C154C122 4EFA4415 F1AAEBCC 315F3A7D2580735A 7955AA57 850ABD88 72A1DDD88D2CE060 CF980C29 890D74F2 53131895281E324E 98EA1FEF 7FF69A12 17CA7784490862AF 833E133D FD22141D D8C89B944C10A4D2 24693D70 AE37C18F 72EF0BE51ED60704 651BC71F 16CA1B77 496A0B19463EDFF9 6BEB1861 CA5BAD96 89D0118E—— END LICENSE —— —– BEGIN LICENSE —–Nicolas HennionSingle User LicenseEA7E-8660758A01AA83 1D668D24 4484AEBC 3B04512C827B0DE5 69E9B07A A39ACCC0 F95F5410729D5639 4C37CECB B2522FB3 8D37FDC172899363 BBA441AC A5F47F08 6CD3B3FECEFB3783 B2E1BA96 71AAF7B4 AFB61B1D0CC513E7 52FF2333 9F726D2C CDE53B4A810C0D4F E1F419A3 CDA0832B 8440565A35BF00F6 4CA9F869 ED10E245 469C233E—— END LICENSE —— —– BEGIN LICENSE —–Anthony SansoneSingle User LicenseEA7E-87856328B9A648 42B99D8A F2E3E9E0 16DE076EE218B3DC F3606379 C33C1526 E8B58964B2CB3F63 BDF901BE D31424D2 082891B5F7058694 55FA46D8 EFC11878 0868F093B17CAFE7 63A78881 86B78E38 0F146238BAE22DBB D4EC71A1 0EC2E701 C7F9C6485CF29CA3 1CB14285 19A46991 E9A9867614FD4777 2D8A0AB6 A444EE0D CA009B54—— END LICENSE —— —– BEGIN LICENSE —–Alexey PlutalovSingle User LicenseEA7E-8607763DC19CC1 134CDF23 504DC871 2DE5CE55585DC8A6 253BB0D9 637C87A2 D8D0BA85AAE574AD BA7D6DA9 2B9773F2 324C5DEF17830A4E FBCF9D1D 182406E9 F883EA87E585BBA1 2538C270 E2E857C2 194283CA7234FF9E D0392F93 1D16E021 F191491763909E12 203C0169 3F08FFC8 86D06EA873DDAEF0 AC559F30 A6A67947 B60104C6—— END LICENSE —— —– BEGIN LICENSE —–Peter HallidaySingle User LicenseEA7E-8559883997BFF0 2856413A 7A555954 67069B7806D8CE12 63EAF079 AD039757 79E16D13C555AD90 465CBE53 10F6DFC4 D3A3C611411106F8 0CFEB15F 0A7BB891 111F5ED2C6AA8429 77913528 FA6291A9 B88D4550F1D6AB13 BF9153BC 91B4DFFE D296CFE0C1D8EB22 13D5F14E 75A699EC 49EDDC23D89D0F9B D240B10A A3712467 09DE7870—— END LICENSE —— —– BEGIN LICENSE —–Fred ZirdungSingle User LicenseEA7E-8446726089C0EC 22936E1A 1EADEBE2 B8654BBA5C98FFA6 C0FD1599 0364779B 071C74FBEEFE9EAB 92B3D867 CD1B32FE D190269F6FC08F8F 8D24191D 32828465 942CE58EAECE5307 08B62229 D788560A 6E0AAC4B48A2D9EE 24FD8CAA 07BEBDF2 28EA86D4CCB96084 6C34CAD2 E8A04F39 3B5A3CBC3B668BB7 C94D0B4B 847D6D7F 4BC07375—— END LICENSE —— —– BEGIN LICENSE —–WixelSingle User LicenseEA7E-848235103D2969 8700C7ED 8173CF61 537000C0EB3C7ECB 5E750F17 6B42B67C A190090B7669164F C6F371A8 5A1D88D5 BDD0DA70C065892B 7CC1BB2B 1C8B8C7C F08E77897C2A5241 35F86328 4C8F70D9 C023D7C211245C36 59A730DB 72BDB9A7 D5B2030490E90E72 9F08CA25 73F49C20 179D938E5BC8BEDA 13457A69 39E6265F 233767F9—— END LICENSE —— —– BEGIN LICENSE —–Daniel RusselSingle User LicenseEA7E-9174209327EC62 44020C2A 45172A68 12FE13F11D22245B 680892EE F551F8EB C183D0328B4EDB4B 479CB7E4 07E42EDD A780021D56BADF42 AC05238B 023B47B1 EBA1B7DE6DF9A383 159F32AE 04EBE100 1278B1D252E81B60 C68AA2E8 F84A20BE FE7990EB5D44E4B6 16369263 1DDAACBC 280FF19E86CF4319 0B8615A8 4FF0512E B123B8EC—— END LICENSE —— —– BEGIN LICENSE —–Peter ErikssonSingle User LicenseEA7E-8900688E107C71 3100D6FC 2AC805BF 9E627C7772E710D7 43392469 D06A2F5B F9304FBDF5AB4DB2 7A95F172 FE68E300 42745819E94AB2DF C1893094 ECABADC8 71FEE76420224821 3EABF931 745AF882 87AD0A4B33C6E377 0210D712 CD2B1178 82601542C7FD8098 F45D2824 BC7DFB38 F1EBD38AD7A3AFE0 96F938EA 2D90BD72 9E34CDF0—— END LICENSE —— —– BEGIN LICENSE —–Ryan ClarkSingle User LicenseEA7E-8124792158A7DE B690A7A3 8EC04710 006A5EEB34E77CA3 9C82C81F 0DB6371B 79704E6F93F36655 B031503A 03257CCC 01B20F60D304FA8D B1B4F0AF 8A76C7BA 0FA94D5556D46BCE 5237A341 CD837F30 4D60772D349B1179 A996F826 90CDB73C 24D41245FD032C30 AD5E7241 4EAA66ED 167D91FB55896B16 EA125C81 F550AF6B A6820916—— END LICENSE —— https://fatesinger.com/78252]]></content>
      <categories>
        <category>ide</category>
      </categories>
      <tags>
        <tag>sn</tag>
        <tag>sublime</tag>
      </tags>
  </entry>
</search>